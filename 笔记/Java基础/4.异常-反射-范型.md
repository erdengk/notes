

## 12.10 泛型

> 泛型（generic）：又称 参数化类型。是JDK 5 出现的新特性。解决数据类型的安全性问题。
>
> 在类声明或实例化时(即创建对象时)只要制定好需要的具体类型即可。

举例说明：

```
Properties<Person> prop = new Properties<Person>();
```

> 上例表示存放到 `prop` 中的必须是 `Person` 类型。
>
> 如果编译器发现添加类型不符合要求，即报错。
>
> 遍历时，直接取出 `Person` 而非 `Object`

1. ==编译时，检查添加元素的类型。可以保证如果编译时没发出警告，运行就不会产生 ClassCastException 异常。提高了安全性，使代码更加简洁、健壮。==

2. 也减少了转换的次数，提高了效率。

3. ==泛型的作用是：可以在类声明是通过一个标识表示类中某个属性的类型，或某个方法返回值的类型，或参数类型。==

   ```
   class P<E> {
   	E e;				//E 表示 e 的数据类型，在定义 P类 时指定。在编译期间即确认类型
   	public P(E e){		//可作为参数类型
   		this.e = e;
   	}
   	public E doSth(){	//可作为返回类型
   		return this.e;
   	}
   }
   ```

   实例化时指定 E 的类型，编译时上例所有 E 会被编译器替换为那个指定类型

#### 使用方法：

- **声明泛型：**

  ```
  interface InterfaceName<T> {...}
  class ClassName<A, B, C, D> {...}
  ```

  上例 T、A、B、C、D 不是值，而是类型。可以用任意字母代替

- **实例化泛型：**

  ```
  List<String> strList = new ArrayList<String>();
  Iterator<Integer> iterator = vector.interator<Integer>();
  ```

  类名后面指定类型参数的值

**注意细节：**

1. 泛型只能是引用类型

2. 指定泛型具体类型后，可以传入该类型或其子类类型

3. 在实际开发中往往简写泛型

   ```
   List<String> strList = new ArrayList<>();
   ```

   编译器会进行类型推断，右边 `< >` 内容可以省略

4. 实例化不写泛型的场合，相当于默认泛型为 `Object`

#### 自定义泛型类 · 接口：

```
class Name<A, B...> {...}				//泛型标识符 可有多个，一般是单个大写字母表示
```

这就是自定义泛型啊

1. 普通成员可以使用泛型（属性、方法）

2. 泛型类的类型，是在创建对象时确定的。

   因此：静态方法中不能使用类的泛型；使用泛型的数组，也不能初始化。

3. 创建对象时不指定的场合，默认 Object。建议还是写上 `<Object>`，大气，上档次

4. 自定义泛型接口

   ```
   interface Name<T, R...> {...}
    
   ```

   泛型接口，其泛型在 继承接口 或 实现接口 时确定。

#### 自定义泛型方法：

```
修饰符 <T, R...> 返回类型 方法名(形参) {...}

```

1. 可以定义在普通类中，也可以定义在泛型类中

2. 当泛型方法被调用时，类型会确定

3. 以下场合

   > ```
   > Class C<T> {
   > 	public void cMethord(T t){		
   > 	}
   > }
   >  
   > ```

   没有 `< >`，不是泛型方法，而是使用了泛型的普通方法

#### 泛型继承：

1. 泛型不具有继承性
2. `<?>`：支持任意泛型类型
3. `<? extends A>`：支持 A 及 A的子类，规定了泛型的上限
4. `<? super B>`：支持 B 及 B 的父类，规定了泛型的下限