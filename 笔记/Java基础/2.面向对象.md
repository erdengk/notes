# 2 面向对象编程（基础）

> 面向对象是一种开发软件的方法，使分析、设计和实现一个系统的方法尽可能接近人们认识一个系统的方法。包括三个方面：面向对象分析、面向对象设计、面向对象程序设计。
>
> Java 语言是纯面向对象的语言。其所有数据类型都有相应的类，程序可以完全基于对象编写。

### 2.1.4 类与对象的内存访问机制

> 栈：一般存放基本数据类型（局部变量）
>
> 堆：存放对象（如`Cat cat1 = new Cat()`，是在这里开辟的空间）
>
> 方法区：常量池（常量，比如字符串），类加载信息

1. 创建对象时，先加载 类 信息，然后在 堆 中分配空间，栈 中的对象名被赋予指向那个空间的地址。
2. 之后进行指定初始化。该对象的 属性 中，是 基本数据类型 的直接记录在 堆 中；是 字符串 的记录一个地址，该地址指向 方法区，那里的常量池有该字符串。

## 2.2 方法重载

> 方法重载（Overload）：Java 中允许同一类中，多个同名方法的存在，但要求 形参列表 不一致。

**使用细节：**

1. 方法名：必须相同
2. 形参列表：必须不同（参数的类型、个数、顺序，这其中至少一个不同）
3. 返回值：无要求

**签名：**

由于重载的存在，要完整的描述一个方法，要指定方法名及参数类型。这叫做方法的签名。

如：

```
public void act() {}
public int act(int n) {
    return n;
}
```

两个方法的签名分别是：`act()` 和 `act(int n)`

## 2.3 构造方法、构造器

> 构造方法又叫构造器（constructor），是类的一种特殊的方法。它的主要作用是完成对新对象的初始化。

语法：`[修饰符] 方法名(形参列表){方法体}`

1. 构造器的修饰符可以是默认。也可以是别的
2. 参数列表 规则同 成员方法

以下示范一个构造器：

```
class T{
	String name;
	int mun;
    //下面这块就是构造器
	public T(String str, int i){
		name = str;
		num = i;
	}
}
```

### 2.3.1 使用细节

1. 构造器本质也是方法。所以，可以 构造器重载。
2. 构造器名 和 类名 相同
3. 构造器无返回值
4. 构造器是完成对象的初始化，而不是创建
5. 创建对象时，系统自动调用构造器
6. 如果程序员没有定义构造器，系统会自动给类生成一个无参构造器（默认构造器）
7. 一旦定义了自己的构造器，就不能用无参构造器了。除非显式的定义一个无参构造器

## 2.4 this 关键字

> JVM 会给每个对象分配 this 代表当前对象。
>
> 相当于在 堆 中，this 指向自己（对象）
>
> 在类定义的方法中，Java 会自动用 this 关键字把所有变量和方法引用结合在一起。
>
> 遇到有同名的局部变量的场合，需要程序员加入 this 关键字进行区分。不加入 this 关键字的场合，Java 遵循就近原则。

```
class Example{
    int n = 0;
	public void act(int n) {}
}
JAVA
```

上面这个类的 `act()` 方法实际有 2 个参数。对其调用：

```
Example e = new Exmaple();
e.act(100);
JAVA
```

可见，出现在方法名前的参数 `e`，以及出现在方法名后的括号中的参数 `100`

出现在方法名前的参数被称为 **隐式参数**（也称为 方法调用的 目标 或 接收者）

出现在方法名后的参数被称为 **显式参数**，就是所谓的实参

在每一个方法中，用 this 指代隐式参数。

```
public void act(int n) {
    this.n = n;
}
JAVA
```

此时，再以相同方式调用方法：

```
e.act(100);					// <———— 相当于 e.n = 100;
JAVA
```

### 2.4.1 使用方法

1. `this` 关键字可以用来访问本类的属性、方法、构造器

2. `this` 用于区分当前类的 属性 和 局部变量

3. 访问本类中成员方法的语法：`this.方法名`

4. 访问构造器的语法：`this(参数列表);`

   注意：只能在构造器中访问另一个构造器。而且，如果有这个语法，必须放置在第一条语句。

5. `this` 不能在类定义的 外部 使用，只能在类定义的 方法中 使用

## 2.5 包

> 包的作用：1. 区分相同名字的类 2. 当类很多时，便于管理 3. 控制访问范围
>
> 语法：`package com.name` 其中 `com` `name` 分别是 一级 和 二级目录，用 `.` 分隔
>
> 包的本质：就是创建不同 文件夹/目录 来保存 类 文件

7 面向对象编程（中级） ★

 2021年12月5日 凌晨

 11k 字 31 分钟 262 次

本文最后更新于：2022年7月6日 早上

# 3 面向对象编程（中级）

## 3.1 包

> 包的作用：1. 区分相同名字的类 2. 当类很多时，便于管理 3. 控制访问范围
>
> 语法：`package com.name` 其中 `com` `name` 分别是 一级 和 二级目录，用 `.` 分隔
>
> 包的本质：就是创建不同 文件夹/目录 来保存 类 文件

## 3.2 访问修饰符

### 3.2.1 访问权限特点

Java 提供 4 种 访问控制修饰符号，用于控制方法和属性（成员变量）的访问权限（范围）

- 公开级别：`public`，对外公开。
- 受保护级别：`protected`，对 子类 和 同一个包中的类 公开。
- 默认级别：没有修饰符号，向 同一个包的类 公开。
- 私有级别：`private`，只有 同类 可以访问，不对外公开。

|                | 默认（无修饰符） | private | protected | public |
| -------------- | :--------------: | :-----: | :-------: | :----: |
| 本类           |        可        |   可    |    可     |   可   |
| 同包中的子类   |        可        | 不可以  |    可     |   可   |
| 同包的非子类   |        可        | 不可以  |    可     |   可   |
| 其他包的子类   |      不可以      | 不可以  |    可     |   可   |
| 其他包的非子类 |      不可以      | 不可以  |  不可以   |   可   |

## 3.3 继承

> 继承：能解决代码复用，让我们的编程更接近人类思维。当多个类存在相同的 属性（变量）和 方法 时，可以从这些类中抽象出 父类（基类/超类）。在 父类 中定义这些属性·方法，所有的子类不需要重新定义这些属性和方法，只需要通过 `extends` 来声明继承父类即可。
>
> 通过继承的方法，代码的复用性提高了，代码的维护性和拓展性也提高了。

```
public class Son extends Father {};				// Son 类继承了 Father 类
```

定义类时可以指明其父类，也能不指明。不指明的场合，默认继承 Object 类。

**所有类有且只有一个父类。Object 是所有类的直接或间接父类。只有 Object 本身没有父类。**

### 3.1.1 使用细节

1. 子类 继承了所有属性和方法，但私有（`private`）的 属性·方法 不能在 子类 直接访问。要调用父类提供的 公共（`public`）等方法 访问。
2. 子类 必须调用 父类 的 构造器，完成 父类 的 初始化。
3. ==当创建 子类对象 时，不管使用 子类的哪个构造器，默认情况下总会调用 父类的无参构造器==。==如果 父类 没有提供 无参构造器，则必须在 子类的构造器 中用 `super` 去指定使用 父类的哪个构造器 完成 对父类的初始化。否则编译不能通过。==
4. ==如果希望指定调用 父类的某构造器，则显式地调用一下：`super(形参列表);`==
5. ==`super` 在使用时，必须放在构造器第一行。`super` 只能在构造器中使用。==
6. ==由于 `super` 与 `this` 都要求放在第一行，所以此两个方法不能同时存在于同一构造器。==
7. Java 所有的类都是 `Object` 的子类。换言之，`Object` 是所有类的父类。
8. ==父类构造器的调用不限于直接父类，将持续向上直至追溯到顶级父类 `Object`==
9. 子类 最多只能直接继承 一个 父类。即，Java 中是 单继承机制。
10. 不能滥用继承。子类 和 父类 之间必须满足 is - a 的逻辑关系。
11. **值得注意的是子类可以继承父类的私有成员（成员变量，方法），只是子类无法直接访问而已，可以通过getter/setter方法访问父类的private成员变量。**

### 3.1.2 继承的本质

- 内存布局：
  1. 在 方法区，自顶级父类起，依次加载 类信息。
  2. 在 堆 中开辟一个空间，自顶级父类起，依次创建并初始化各个类包含的所有属性信息。
  3. 在 栈 中存放该空间的 地址。
- 如何查找信息？
  1. 查看该子类是否有该属性。如果该子类有这个属性且可以访问，则返回信息。
  2. 子类没有该属性的场合，查看父类是否有该属性。如有且可访问，则返回信息。如不可访问，则报错。
  3. 父类也没有该属性的场合，继续查找上级父类，直到顶级父类（Object）。
  4. 如需调用某个特定类包含的特定信息，可以调用该类提供的方法。

### 3.1.3 super 关键字

> `super` 代表父类的引用。用于访问父类的 属性、方法、构造器。

**super 的使用：**

- `super.属性名`：访问父类的属性。不能访问父类的私有（private）属性。
- `super.方法名(形参列表)`：访问父类的方法。不能访问父类的私有（private）方法。
- `super(参数列表);`：访问父类的构造器。此时，super 语句必须放在第一句。

**使用细节：**

1. 调用父类构造器，好处是分工明确。父类属性由父类初始化，子类由子类初始化。
2. 子类中由和父类中成员（属性和方法）重名时，要调用父类成员必须用 `super`。没有重名的场合，`super`、`this` 及直接调用的效果相同。
3. `super` 的访问不限于直接父类。如果爷爷类和本类中都有同名成员也能使用。如果多个基类中都有同名成员，则遵循就近原则。

### 3.1.4 方法重写 / 覆盖

> 方法重写/覆盖（Override）：如若子类有一个方法，和父类的某方法的 名称、返回类型、参数 一样，那么我们就说该子类方法 覆盖 了那个父类方法。

**声明不变，重新实现**

**使用细节：**

1. ==子类方法的参数，方法名称，要和父类方法完全一致。==
2. ==子类方法的返回类型需和父类方法 一致，或者是父类返回类型的子类。==
3. ==子类方法 **不能缩小** 父类方法的访问范围（访问修饰符）。==

## 3.4 多态

> 多态：方法 或 对象 有多种形态。多态 是面向对象的第三大特征，是建立在 封装 和 继承 的基础之上的

### 3.4.1 多态的体现

1. 方法的多态：重写 和 重载 体现了 方法的多态。

2. **对象的多态：**

   - 一个对象的 编译类型 和 运行类型 可以不一致。

     `Animal animal = new Dog();`

     上例，编译类型是 `Animal`，运行类型是子类 `Dog`。`animal` 是对象的**引用**。

   - 编译类型在定义对象时就确定了，不能改变。

   - 运行类型是可以变化的。

     上例中，再让 `animal = new Cat();`，这样，运行类型变为了 `Cat`

   - ==编译类型看定义时 `=` 的左边，运行类型看 `=` 的右边。==

### 3.4.2 使用细节

1. 多态的前提：两个对象 / 类存在继承关系。

2. 多态的向上转型：

   - 本质：父类的引用指向了子类的对象。
   - 语法：`父类类型 引用名 = new 子类类型(参数列表);`
   - 编译类型看左边，运行类型看右边。
   - 可以调用父类中的所有成员，但不能调用子类特有的成员，而且需要遵守访问权限。因为在编译阶段，能调用哪些成员是由编译类型决定的。
   - 最终的运行结果要看子类的具体实现。即从子类起向上查找方法调用

3. 多态的向下转型：

   - 语法：`子类类型 引用名 = (子类类型)父类引用;`

      向下转型。这个语法其实和很像。

     `Dog dog = (Dog)animal;`

   - ==只能强转父类的引用，不能强转父类的对象。==

   - 要求父类的引用必须指向的是当前目标类型的对象。即上例中的 `animal` 运行类型需是 `Dog`

   - 向下转型后，可以调用子类类型中的所有成员。

4. 属性没有重写一说。**和 方法 不同，属性的值 看编译类型。**

5. `instanceof` 比较操作符。用于判断对象类型是否是某类型或其子类型。此时判断的是 **运行类型**。

### 3.4.3 理解方法调用

在对象上调用方法的过程如下：

1. 编译器查看对象的声明类型和方法名。该类和其父类中，所有同名方法（包括参数不同的方法）都被列举。

   至此，编译器已经知道所有可能被调用的方法。

2. 编译器确认方法调用中提供的参数类型。

   那些列举方法中存在参数类型完全匹配的方法时，即调用该方法。

   没有发现匹配方法，抑或是发现经过类型转换产生了多个匹配方法时，就会报错

   至此，编译器已经知道要调用方法的名字和参数类型

3. 如若是 private 方法、static 方法、final 方法、构造器，那么编译器将能准确知道要调用哪个方法。这称为 **静态绑定**

   与之相对的，如果调用方法依赖于隐式参数类型，那么必须在运行时 **动态绑定**

4. 程序运行并采取动态绑定方法时，JVM 将调用那个 **实际类型** 对应的方法。

倘若每次调用方法都进行以上搜索，会造成庞大的时间开销。为此，JVM 预先为每个类计算了 **方法表**。

方法表中列举了所有方法的签名与实际调用的方法。如此，每次调用方法时，只需查找该表即可。

特别地，使用 super 关键字时，JVM 会查找其父类的方法表。

**动态绑定机制：**

- 当调用对象方法的时候，该方法和该对象（隐式参数）的内存地址/运行类型绑定。
- 当调用对象属性时，没有动态绑定机制。于是哪里声明，哪里调用。

### 多态的弊端

我们已经知道多态编译阶段是看左边父类类型的，如果子类有些独有的功能，此时**多态的写法就无法访问子类独有功能了**。

```java 
class Animal{
    public  void eat()｛
        System.out.println("动物吃东西！")
    ｝
}
class Cat extends Animal {  
    public void eat() {  
        System.out.println("吃鱼");  
    }  
   
    public void catchMouse() {  
        System.out.println("抓老鼠");  
    }  
}  

class Dog extends Animal {  
    public void eat() {  
        System.out.println("吃骨头");  
    }  
}

class Test{
    public static void main(String[] args){
        Animal a = new Cat();
        a.eat();
        a.catchMouse();//编译报错，编译看左边，Animal没有这个方法
    }
}
```

## 3.5 Object 类

Object 类是所有类的超类。Java 中所有类默认继承该类。

### equals 方法

```
boolean equals(Object obj)
```

用于检测一个对象是否等于另一对象。

在 Object 中，该方法的实现是比较 形参 与 隐式参数 的对象引用是否一致。

**与 `= =` 的区别：**

- `= =`：==既可以判断基本类型，也可以判断引用类型。如果判断基本类型，判断的是值是否相等。如果判断引用类型，判断的是地址是否相等==。

- equals 方法：是 Object 中的方法，==只能判断引用类型。默认判断地址是否相等，但子类中往往重写该代码，以判断内容是否相等==。

  在子类中定义 equals 方法时，首先调用超类的 equals 方法。那个一致时，再比较子类中的字段。

**Java 语言规范要求 equals 方法具有如下特性：**

- *自反性*：对于任何非空引用 x，`x.equals(x)` 应返回 true

- *对称性*：对于任何引用 x 和 y，当且仅当 `x.equals(y)` 为 true 时，`y.equals(x)` 为 true

  如果所有的子类具有相同的相等性语义，可以使用 `instanceof` 检测其类型。否则，最好使用 `getClass` 方法比较类型。

- *传递性*：对于任何引用 x、y、z，如果 `x.equals(y)` 为 true ，`y.equals(z)` 为 true，那么 `x.equals(z)` 也应该为 true

- *一致性*：如果 x 和 y 的引用没有发生变化，反复调用 `x.equals(y)` 应该返回相同的结果

- 对于任何非空引用 x，`x.equals(null)` 应该返回 false

### hashCode 方法

```
int hashCode()
```

返回对象的 散列码值。

散列码值是由对象导出的一个整型值。散列码是无规律的。如果 x 与 y 是不同对象，两者的散列码基本上不会相同。

字符串的散列码是由其内容导出的，而其他引用对象的散列码是根据存储地址得出的。

**散列码的作用：**

1. 提高哈希结构的容器的效率。
2. 两个引用，若是指向同一对象，则哈希值一般不同。
3. 哈希值是根据地址生成的，因而，哈希值不能等同于地址

**相关方法：**

- `Objects.hashCode(Object obj)`

  这是一个 null 安全的返回散列值的方法。传入 null 时会返回 0

- `Objects.hash(Object... values)`

  组合所有传入参数的散列值

- `Integer.hashCode(int value)`

  返回给定基本数据类型的散列值。所有包装类都有该静态方法

- `Arrays.hashCode(xxx[] a)`

  计算数组的散列码。数组类型可以是 Object 或基本数据类型

空对象调用 hashCode 方法会抛出异常。

hashCode 与 equals 的定义必须相符。如果 `x.equals(y)` 返回 true，那么 `x.hashCode()` 与 `y.hashCode()` 应该返回相同的值。

### toString 方法

```
String toString()
```

返回表示对象的一个字符串。Object 的默认实现如下

```
public String toString() {
    return getClass().getName() + "@" + Integer.toHexString(hashCode());
}
JAVA
```

- `Class getClass()`

  返回包含对象信息的 Class 对象。

- `String getName()`

  由 Class 类实例调用。返回这个类的全类名

  全类名：即包名 + 类名。比如 `com.prictice.codes.Person`

- `Class getSuperClass()`

  由 Class 类实例调用。以 Class 形式返回其父类

  Object 使用时返回 null

- `Integer.toHexString(int val)`

  返回一个数字的十六进制表示的字符串

toString 方法非常实用。Java 标准类库中的很多类重写了该方法，以便用户能获得一些有关对象状态的信息。

打印对象 或 使用 **+** 操作符拼接对象 时，都会自动调用该对象的 toString 方法。

当直接调用对象时，也会默认调用该方法。

### finalize 方法

1. 当对象被回收时，系统会自动调用该对象的 `finalize` 方法。子类可以重写该方法，做一些释放资源的操作。
2. 何时被回收：当某对象没有任何引用时，JVM 就认为该对象是一个垃圾对象，就会（在算法决定的某个时刻）使用垃圾回收机制来销毁该对象。在销毁该对象前，会调用 `finalize` 方法。
3. 垃圾回收机制的调用，是由系统决定。也可以通过 `System.gc();` 主动触发垃圾回收机制。这个方法一经调用就会继续执行余下代码，而不会等待回收完毕。
4. 实际开发中，几乎不会运用该方法。



# 9 面向对象编程（高级）

## 9.1 类变量和类方法

### 9.1.1 类变量

> 类变量：也叫 静态变量/静态属性。是该类所有对象共享的变量。任何一个该类对象访问时都是相同的值，任何一个该类对象修改时也是同一个变量。
>
> 语法（推荐）：`访问修饰符 static 数据类型 变量名;`
>
> 或者也可以：`static 访问修饰符 数据类型 变量名;`
>
> 根据 JDK 版本的不同，类变量存放在 堆 中或 方法区 中。

1. 什么时候需要用类变量：

   ==当我们需要让某个类的所有对象都共享一个变量时，就可以考虑使用类变量（静态变量）==

2. 类变量 与 实例变量（普通属性）的区别：

   类变量 是该类所有对象共享的，而 实例变量 是每个对象独享的

3. ==加上 `static` 称为 类变量 或 静态变量。否则称为 实例变量/普通变量/非静态变量==

4. 静态变量 可以通过 `类名.类变量名;` 或 `对象名.类变量名;` 来访问。但 Java 设计者推荐我们用 `类名.类变量名;` 来访问。（需满足访问权限和范围）

5. 类变量 是在加载类时就初始化了。所以，没有创建对象实例也能访问。

6. 类变量 的生命周期是随着 类的加载 开始，随着 类的消亡 而销毁。

7. 特别地：**一个 null 对象也可以访问静态变量 / 静态方法**

   ```
   public class Test{
       static int n = 0;
       static void met() {
           System.out.println(++n);
       }
       
       public static void main(String[] args){
           Test t = null;
           System.out.println(t.n);			//这样不会报错
           t.met();							//这样也不会报错
       }
   }
   ```

### 9.1.2 类方法

> 当方法使用 `static` 修饰后，就是 静态方法。静态方法就能访问静态属性。如果我们不希望创建实例，也能调用方法，这个场合把方法做成静态方法是合适的。开发工具类时就可以如此做。

1. 类方法和普通方法都是随着类的加载而加载，将结构信息存储在 方法区。
2. 类方法中不允许使用和对象有关的关键字。所以，类方法没有 `this` 或 `super`
3. 类方法可以通过类名调用，也能通过对象名调用。普通方法不能通过类名调用。
4. 类方法 中只能访问 类变量 或 类方法
5. 普通方法既可以访问普通方法也可以访问类方法

## 9.2 理解 main方法语法

> ```
> public static void main(String[] args){...}
> ```

1. `main` 方法 是 JVM 调用的方法。所以该方法的 访问权限 必须为 `public`

2. JVM 在执行 `main` 方法时不必创建对象，所以 `main`方法 必须为 `static`

3. 该方法接收 `String` 类型的数组参数。该数组中保存执行 Java 命令 时传递给所运行的类的参数。

   > 工作台中：`javac 执行的程序.java`
   >
   >  `java 执行的程序 参数1(arg[0]) 参数2(arg[1]) 参数3(arg[2]) ..`
   >
   > [IDEA中怎么做？](https://www.bilibili.com/video/BV1fh411y7R8?p=385&t=129.5)

4. 在 `main` 方法 中，我们可以直接调用 `main` 方法 所在类的静态方法或静态属性。

   但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例后才能通过该实例访问非静态成员。

## 9.3 代码块

> 代码块：又称为 初始化块。属于类中的成员。类似于方法，将逻辑语句封装在方法体中，通过 `{ }` 包围起来。
>
> 和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类 显式调用，而是加载类时，或创建对象时 隐式调用。
>
> 语法：`[修饰符]{代码};`

1. 修饰符 是可选项，可不写。要写的话，只能写 `static`

2. 代码块分为两类：

   - 静态代码块：有 `static`
   - 实例/普通代码块：无 `static`

3. 逻辑语句可以为任意的逻辑语句。

4. `;` 可以写，也可以省略。建议写上。

5. ==代码块相当于另一种形式的构造器（构造器的补充机制），可以做初始化操作==

   **特点**：

   - 每次执行类，加载类的时候都会先执行静态代码块一次。
   - 静态代码块是自动触发执行的，只要程序启动静态代码块就会先执行一次。
   - 作用：在启动程序之前可以做资源的初始化，一般用于初始化静态资源。

### 9.3.1 使用细节

1. `static` 代码块：作用是对类进行初始化。**随着 类的加载 会且只会执行一次**。相对的：普通代码块每创建一个对象就执行一次。

- **类什么时候被加载？ **

  - 创建对象实例时（new）
  - 创建子类对象实例，父类也会加载
  - 使用类的静态成员时（父类也会加载）

  以上情况下类会被加载。加载后不需要再次加载，所以，静态代码块也只会执行一次。

1. ==创建一个对象时，在 **一个类里** 调用顺序是：==

   - 调用静态代码块 和 静态属性初始化。这两者优先级相同，多个存在时按照定义的顺序依次执行。
   - 调用普通代码块 和 普通属性初始化。这两者优先级也相同。
   - 调用构造器。

2. `构造器` 的最前面其实隐含了 `super();` 和 `调用普通代码块`。而静态相关的代码块，属性初始化，在类加载时就执行完毕了。

   ==这样，创建一个对象时，在 **有继承关系的多个类里** 调用顺序是：==

   - 父类 静态代码块 和 静态初始化
   - 子类 静态代码块 和 静态初始化
   - 父类 普通代码块 和 普通初始化
   - 父类 构造器
   - 子类 普通代码块 和 普通初始化
   - 子类 构造器

3. 静态代码块 只能调用 静态成员。普通代码块 能调用 任意成员。

## 9.3-1 实例代码块

**实例代码块**
​         没有static修饰，必须放在类下。与对象初始化一起加载。

**格式**

```java
{
     // 执行代码
}
```

**特点**：

- 无static修饰。属于对象，与对象的创建一起执行的。
- ==每次调用构造器初始化对象，实例代码块都要自动触发执行一次。==
- 实例代码块实际上是提取到每一个构造器中去执行的。
- 作用：实例代码块用于初始化对象的资源。

**案例演示**

```java
public class Test {
    private String name ;

    // 实例代码块。 无static修饰。
    {
        System.out.println("实例代码块执行");
        name = "dl";
    }

    // 构造器
    public Test(){
        System.out.println("空参实例代码块执行");
    }

    // 有参数构造器
    public Test(String name){
        System.out.println("有参-实例代码块执行"+name);
    }

    public static void main(String[] args) {
        // 匿名对象，创建出来没有给变量。
        new Test();
        new Test();
        new Test("xulei");
    }
}

实例代码块执行
空参实例代码块执行
实例代码块执行
空参实例代码块执行
实例代码块执行
有参-实例代码块执行xulei
```



## 9.4 单例设计模式

> 什么是设计模式：设计模式是在大量的实践中总结和理论化后优选的代码结构、编程风格、解决问题的思考方式。设计模式就像是经典的棋谱，免去我们自己再思考和摸索。

单例设计模式：采取一定的方法，保证再整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法

### 9.4.1 应用实例

> 后面会学更多，这里先展示两种：饿汉式、懒汉式

#### 9.4.1.1 饿汉式

步骤如下：

1. ==构造器私有化（防止用户直接 new）==

2. 类的内部创建对象

3. 向外暴露一个静态的公共方法

4. 代码实现

   > ```java
   > public class Singleton {
   >     // 1.将构造方法私有化，使其不能在类的外部通过new关键字实例化该类对象。
   >     private Singleton() {}
   > 
   >     // 2.在该类内部产生一个唯一的实例化对象，并且将其封装为private static类型的成员变量。
   >     private static final Singleton instance = new Singleton();
   >     
   >     // 3.定义一个静态方法返回这个唯一对象。
   >     public static Singleton getInstance() {
   >         return instance;
   >     }
   > }
   > ```
   >
   > 对象，通常都是重量级的对象
   >
   > 有时，我们用不到这个创建的对象，那个场合，会造成资源浪费。

#### 9.4.1.2 懒汉式

步骤如下：

1. 构造器私有化

2. 定义一个静态属性对象

3. 提供一个静态的公共方法，可以返回对象。如果静态对象为空，则创建对象

4. 代码实现

   > ```java
   > public class Singleton {
   > 
   >     // 2.在该类内部产生一个唯一的实例化对象，并且将其封装为private static类型的成员变量。
   >     private static Singleton instance;
   >     
   >     // 1.将构造方法私有化，使其不能在类的外部通过new关键字实例化该类对象。
   >     private Singleton() {}
   >     
   >     // 3.定义一个静态方法返回这个唯一对象。要用的时候才例化出对象
   >     public static Singleton getInstance() {
   >         if(instance == null) {
   >             instance = new Singleton();
   >         }
   >         return instance;
   >     }
   > }
   > ```

#### 9.4.1.3 两种方法对比

1. ==二者创建对象的时机不同。饿汉式在加载类信息时创建，懒汉式在使用时才创建==
2. ==饿汉式可能造成资源浪费，懒汉式可能存在线程安全问题（学习[线程]后会进行完善）。==
3. Java SE 标准类中 java.lang.Runtime 就是一个单例模式。

## 9.5 final

> `final` 可以修饰 类、属性、方法、局部变量
>
> 以下情况下，可能用到 `final`
>
> 1. `final` 修饰类：该类不能被继承
> 2. `final` 修饰方法：该方法不能被重写
> 3. `final` 修饰值：该值不能被修改

### 9.5.1 使用细节

1. `final` 修饰的属性又叫常量，一般用 XX_XX_XX 来命名（全大写字母+下划线）

2. `final` 修饰的属性在定义时，必须赋初始值，且之后不能再修改。赋值可以在下列位置之一：

   - 定义时
   - 构造器中
   - 代码块中

   注意：如果 `final` 修饰的属性是静态的，则只能在以下位置赋值。

   - 定义时
   - 静态代码块中

3. `final` 类不能继承，但能实例化对象。对的，是可以的。

4. 如果不是 `final` 类，但含有 `final` 方法，虽然该方法不能重写，但能被继承。

5. `final` 类可以有 `final` 方法。可以，但没必要。

6. `final` 不能修饰构造方法。

7. `final` 和 `static` 搭配使用，效率更高（那个场合，虽然顺序不限，还是推荐 `static` 在前）。底层编译器做了优化处理。这样做，调用 **属性（定义时赋值）** 时居然 **不会造成类的加载！**

8. 包装类（Integer、Double、Float、Boolean、String等）都是 `final` 类，都不能被继承。

## 9.6 抽象类

> 当父类的某些方法需要声明，却不知道如何实现时，可以将其声明为抽象方法。那个场合，要将该类声明为 `abstract` 类。
>
> 抽象类的价值更多是用于设计。设计者设计好后，让子类继承并实现。也是考官爱问的考点。

> 定义抽象类：`访问修饰符 abstract 类名{...}`
>
> 定义抽象方法（注意：无方法体）：`访问修饰符 abstract 返回值 方法名(形参列表);`

### 9.6.1 使用细节

1. 抽象类不能被实例化
2. 抽象类不一定包含抽象方法。也就是说，抽象类可以没有 `abstract`方法
3. 一旦包含 `abstract` 方法，则该类一定要声明为 `abstract`
4. `abstract` 只能修饰 类 和 方法，不能修饰其他。
5. 抽象类可以有任意成员（非抽象方法、构造器、静态属性等）。即，抽象类本质还是类。
6. 抽象方法不能有主体。即，抽象方法不能实现。
7. 如果一个类继承了 `abstract` 类，则其必须实现所有 `abstract` 方法，除非其自己也是 `abstract` 类。
8. 抽象方法不能用 `private` `final` `static` 来修饰。因为，这些关键词都和 重写 相违背。



## 9.7 接口

> 接口就是给出一些没有实现的方法，封装到一起，到某个类要用的时候，再根据具体情况把这些方法写出来。
>
> 语法：`interface 接口名{...}`
>
> ```
> class 类名 implements 接口名{...必须实现接口的抽象方法...}
> ```
>
> 注意：JDK 7.0 以前，接口中只能是抽象方法。而 JDK 8.0 后，接口可以有静态（`static`）方法、默认（`default`）方法。
>
> 在接口中，抽象方法可以省略 `abstract`

接口中可以存在：

- 属性（只有静态 `static` 属性，可以不加 `static` 关键字）
- 方法（抽象 `abstract` 方法、默认 `default` 实现方法、静态 `static` 方法）

### 9.7.1 使用细节

1. 接口 不能被实例化。
2. 接口中所有方法都是 `public` 方法。接口中的 抽象方法 可以不用 `abstract` 修饰。
3. 一个普通类实现接口，就必须把该接口所有方法都实现。（用快捷键吧 `alt + enter`）
4. 抽象类实现接口，可以不用实现接口的方法。
5. 一个类可以同时实现多个接口。`class Name implements In1,In2{...}`
6. ==接口中的属性只能是 `final` 的，并且是 `public static final` 修饰符。修饰符就算不写，还是这样。==
7. 接口中属性的访问形式：`接口名.属性名`
8. 接口不能 **继承** 其他的类，但可以 **继承** 多个别的接口。（不是也不能 实现 别的接口）
9. 接口的修饰符只能是 `public` 和 默认。这点和类的修饰符相同。

### 9.7.2 实现接口 vs 继承类

1. 当子类继承父类，就自动拥有父类的所有功能。如果需要扩展功能，可以通过接口方式扩展。
2. ==可以认为，接口 是对于 Java 单继承机制的补充。==
3. 继承的价值主要在于：解决代码的复用性和可维护性。
4. 接口的价值主要在于：设计。设计好各种规范，让其他类去实现这些方法。
5. 接口比继承更加灵活。继承需要满足 is - a 的关系，而接口只需要满足 like - a 关系。
6. 接口在一定程度上实现代码解耦。（即：接口规范性 + 动态绑定机制）

### 9.7.3 接口的多态特性

1. 多态参数（接口的引用可以指向实现了接口的类的对象）

   > `viod work(Inerface01 i1){...}` 参数可以传入任意实现该接口的类

2. 多态数组

3. 接口存在多态传递现象

## 9.8 内部类

> 一个类的内部又完整的嵌套了另一个类结构。被嵌套的类被称为 内部类。
>
> ```
> class Outer{		//外部类
> 	class Inner{	//内部类	
> 	}
> }
> class Other{		//外部其他类
> }
> ```
>
> 内部类的最大特点是可以直接访问私有属性，并且可以体现类与类之间的包含关系。

### 9.8.1 四种内部类

分别是：

- 定义在外部类的局部位置上
  - 局部内部类：有 类名，类定义在方法内
  - **匿名内部类：无 类名**，一般定义在方法中，或者可执行代码中
- 定义在外部类的成员位置上
  - 成员内部类：无 `static` 修饰
  - 静态内部类： `static` 修饰的类

### 9.8.2 局部内部类

> 局部内部类：定义在外部类的局部位置上，并且有类名。（局部位置？比如：方法/代码块里）
>
> ```
> class Outer {				//外部类
>     public void tools01() {
>         class Inner {		//局部内部类
>         }
>     }
> }
> ```

#### 9.8.2.1 使用细节

1. 定义在外部类的局部位置上，并且有类名。

2. 可以访问外部类的所有成员，包含私有成员

3. 局部内部类可以 直接访问 外部类的成员。

4. 不能添加 访问修饰符，因为其地位相当于局部变量。但，可以使用 `final`，因为局部变量也能用 `final`

5. 作用域 仅仅在定义它的方法或代码块中

6. 外部类 在方法中，可以创建 局部内部类 的对象实例，然后调用方法。

7. 外部其他类 不能访问 局部内部类

8. 如果外部类和局部内部类的成员重名时，默认遵循就近原则。那个场合，访问外部类成员使用 `外部类名.this.变量名`

   `外部类名.this` 本质就是 外部类的对象。即，调用了该方法（上例的 `tools01` ）的对象

   还不懂的话，看一下 [这个视频](https://www.bilibili.com/video/BV1fh411y7R8?p=415&t=289.9) 悟一悟

### 9.8.3 匿名内部类

> 匿名内部类：定义在外部类的局部位置，且没有类名
>
> ```
> >new 类/接口 (参数列表) {
>    类体
> >}
> JAVA
> ```
>
> 匿名内部类本质是没有名字的类，而且是内部类。同时，还是一个对象。
>
> 可以用匿名内部类简化开发

> 一个例子
>
> ```
> >class Outer {							//外部类
>    public void tools01() {
>        Inter whatEver = new Inter(){	//匿名内部类            
>        };						
>    }
> >}
> >interface Inter{
> >}
> JAVA
> ```
>
> 其实，这个匿名内部类 `new Inter(){}` 的运行类型就是 `class XXXX implements Inter`。系统自动分配的名字是 `Outer$1`（`whatEver.getClass = "Outer$1"`）
>
> JDK 在创建匿名内部类 `Outer$1` 时，立即创建了一个对象实例，并将地址返回给了 `whatEver`
>
> 匿名内部类使用一次后就不能再次使用（`Outer$1` 就这一个了）

#### 9.8.3.1 使用细节

1. 匿名内部类语法比较独特。其既是一个类的定义，也是一个对象。因此，从语法上看，其既有 定义类的特征，也有 创建对象的特征。
2. 可以访问外部类的所有成员，包括私有的。
3. 局部内部类可以 直接访问 外部类的成员。
4. 不能添加 访问修饰符，因为其地位相当于局部变量。但，可以使用 `final`，因为局部变量也能用 `final`
5. 作用域：仅仅在定义它的方法或方法快中
6. 外部其他类 不能访问 匿名内部类
7. 如果外部类和匿名内部类的成员重名时，默认遵循就近原则。那个场合，访问外部类成员使用 `外部类名.this.变量名`

#### 9.8.3.2 使用场景

1. 当作实参直接传递，简洁高效

   > ```
   > public class Homework1 {
   >     public static void main(String[] args) {		
   >         new Cellphone().clock(new Bell() {				//看这里看这里
   >             @Override
   >             public void belling() {
   >                 System.out.println("小懒猪起床了！");
   >             }
   >         });
   >     }
   > }
   > 
   > interface Bell {
   >     void ringing();
   > }
   > 
   > class Cellphone{
   >     public void clock(Bell bell){
   >         bell.ringing();
   >     }
   > }
   > ```

### 9.8.4 成员内部类

> 成员内部类：定义在外部类的成员位置，并且没有 `static` 修饰。
>
> ```
> class Outer{
> 	class Inner{
> 	}
> }
> ```

#### 9.8.4.1 使用细节

1. 可以直接访问外部类的所有成员，包括私有的
2. 可以添加任意访问修饰符。因为，成员内部类的地位就是一个成员。
3. 作用域 和外部类其他成员相同，为整个类体。
4. 局部内部类可以 直接访问 外部类的成员。
5. 外部类可以通过创建对象的方式访问成员内部类
6. 外部其他类访问成员内部类
   - `Outer.Inner name = Outer.new Inner(); `下个方法的缩写
   - `Outer.Inner name = new Outer().new Inner();`
   - 在外部类中编写一个方法，返回一个 `Inner` 的对象实例（就是对象的 getter）
7. 如果外部类和匿名内部类的成员重名时，默认遵循就近原则。那个场合，访问外部类成员使用 `外部类名.this.变量名`

### 9.8.5 静态内部类

> 静态内部类：定义在外部类的成员位置，经由 `static` 修饰。
>
> ```
> class Outer{
> 	static class Inner{
> 	}
> }
> ```

#### 9.8.5.1 使用细节

1. 可以直接访问外部类的所有 **静态** 成员，包括私有的。但不能访问非静态成员
2. 可以添加访问修饰符。因为，静态内部类的地位就是一个成员。
3. 作用域 和其他成员相同，为整个类体。
4. 静态内部类可以 直接访问 外部类的成员。
5. 外部类可以通过创建对象的方式访问静态内部类
6. 外部其他类访问静态内部类
   - `Outer.Inner name = new Outer.Inner();` 即通过类名直接访问
   - 在外部类中编写一个方法，返回一个 `Inner` 的对象实例
   - 如果外部类和匿名内部类的成员重名时，默认遵循就近原则。那个场合，访问外部类成员使用 `外部类名.变量名`。*（怎么不一样了呢？因为静态内部类访问的都是静态成员）*