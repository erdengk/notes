# 并发理论（JMM）

JMM本质上可以理解为，Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。

体来说，这些方法包括：

- volatile、synchronized 和 final 三个关键字
- Happens-Before 规则

**Java提供了volatile关键字来保证可见性**。

当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。

**在Java里面，可以通过volatile关键字来保证一定的“有序性**

##  Java 内存模型的抽象

在 java 中，所有实例域、静态域和数组元素存储在==堆内存==中，==堆内存、和方法区 (JDK1.8 之后的元空间)资源== 在线程之间共享。

但是每个线程有自己的程序计数器、虚拟机栈 和 本地方法栈。

局部变量（Local variables），方法定义参数（java 语言规范称之为 formal method parameters）和异常处理器参数（exception handler parameters）不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。

Java 内存模型的抽象示意图如下：

![](https://pdai.tech/_images/jvm/java-jmm-1.png)

线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读 / 写共享变量的副本。



## 重排序

在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：

- ==编译器优化的重排序==。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
- ==指令级并行的重排序==。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
- ==内存系统的重排序==。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：

![img](https://pdai.tech/_images/jvm/java-jmm-3.png)

上述的 1 属于编译器重排序，2 和 3 属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。

对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。

对于处理器重排序，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。

==JMM 属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证==。

## happens-before

从 JDK5 开始，java 使用新的 JSR -133 内存模型。

JSR-133 提出了 happens-before 的概念，通过这个概念来阐述操作之间的内存可见性。

如==果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。== 与程序员密切相关的 happens-before 规则如下：

- 程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。
- 监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。
- ==volatile 变量规则==：对一个 volatile 域的写，happens- before 于任意后续对这个 volatile 域的读。
- 传递性：如果 A happens- before B，且 B happens- before C，那么 A happens- before C。

==注意，两个操作之间具有 happens-before 关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before 仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前==（the first is visible to and ordered before the second）。happens- before 的定义很微妙，后文会具体说明 happens-before 为什么要这么定义。



## 重排序

### 数据依赖性

写后读\写后写\读后写 

只要重排序两个操作的执行顺序，程序的执行结果将会被改变。

编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，==编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序==。

## ==as-if-serial 语义==

as-if-serial 语义的意思指：==不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变==。编译器，runtime 和处理器都必须遵守 as-if-serial 语义。

```
 area = pi * r * r
```

先乘哪个都行

as-if-serial 语义把单线程程序保护了起来，遵守 as-if-serial 语义的编译器，runtime 和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的。as-if-serial 语义使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。



## JMM 的内存可见性保证

Java 程序的内存可见性保证按程序类型可以分为下列三类：

- ==单线程程序。单线程程序不会出现内存可见性问题。==编译器，runtime 和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。
- ==正确同步的多线程程序。正确同步的多线程程序的执行将具有顺序一致性==（程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。这是 JMM 关注的重点，JMM 通过限制编译器和处理器的重排序来为程序员提供内存可见性保证。
- ==未同步 / 未正确同步的多线程程序。==JMM 为它们提供了最小安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，null，false）。

下图展示了这三类程序在 JMM 中与在顺序一致性内存模型中的执行结果的异同：

![img](https://pdai.tech/_images/jvm/java-jmm-x04.png)

只要多线程程序是正确同步的，JMM 保证该程序在任意的处理器平台上的执行结果，与该程序在顺序一致性内存模型中的执行结果一致。



## 参考

https://juejin.cn/post/6844903600318054413

https://pdai.tech/md/java/thread/java-thread-x-theorty.html

