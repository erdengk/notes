# 大纲

## README

<!--Note-->
### 2021年12月18日 22:02:19
EEEuuuEEE整理合并了一些面经常用题型，去掉了一些进阶的内容，并放上了部分模块的答案。

颜色排序说明：
9 代表别人写的**暂时**用不上或自己还没总结！
1-4 代表自己总结的已经过了一遍，知识的重要程度排序
5 紫色的代表自己总结的大纲，但是还没掌握！



### 协议
分享或者修改演绎时请保留本协议，并署名  [@CyC2018](https://dwz.cn/ZGWCOICD)。

[CC BY - Creative Commons Attribution](http://creativecommons.org/licenses/by-nc-sa/4.0)

![](https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png)

### 目的

方便大家系统梳理知识点，并且针对每个知识点可以在本脑图中写 Markdown 笔记。

每个知识点也有相应的完成度和优先级，对于不同重要程度的知识点应该采取不同的复习方法，从而提高学习效率。

你应该把这个脑图当做最基本的复习材料，每天都要大概地过一遍，保持短期记忆，一定要知道，短期记忆对面试来说至关重要。

也可以将收集的资料整理在本脑图中，从而方便复习。

### 来源

[知识总结方法](https://xiaozhuanlan.com/topic/4150387926)

### 关于我

https://dwz.cn/ZGWCOICD

### 样式修改

百度脑图自带的样式效果不佳，建议安装以下样式脚本：[百度脑图](https://userstyles.org/styles/163774/theme)。

### 保存方法

点击左上角菜单，然后另存为“我的文档”。




<!--/Note-->

## Java语言

<!--Note-->
### 资料

- 《JAVA 核心技术》
- 《Java 编程思想》
- 《Effective java 中文版》
- 《深入理解 Java 虚拟机》
- 《Java 并发编程实战》
- 《精通 Spring 4.x》
- 《Spring 揭秘》
<!--/Note-->

### 语言

- [Java 基础](https://cyc2018.github.io/CS-Notes/#/notes/Java%20基础)

#### 【三大特性】面向对象三大特性？

- 封装：好处两个提高复用性，减少耦合，方便性能监控。

- 继承：子承父类，满足 IS-A 条件的两个类可以用继承来描述这样的关系，子类可以继承其所有属性和方法，也可以对父类进行扩展，或者重写父类方法。

- 多态：三个条件向上转型、接口实现、方法覆盖。举个例子：如果子类**覆盖**了父类的方法A，在执行的时候，可以用父类的引用指向子类（**向上转型**），并且调用方法A，那么实际在执行的过程中执行的是子类的方法。




#### 【Object 的方法】hashcode 和 equals

1. what? 先解释这是干什么的 
	- hashcode 是用来计算对象的 hash 值
	- equals 是用来判断对象是否等价的
	- 如果不重写 hashcode 和 equals 的话，调用的是父类 Object 类里的方法，其实就是把引用的地址值给返回出去。


2. why? 为什么重写 equals 必须重写 hashcode 方法？
    - 因为我们规定等价的两个对象的 哈希值 一定相等，如果不重写 hashcode 的话，两个 new 出来的哈希肯定是不同的。
    - 举个例子：我们 HashSet 和 HashMap 底层都要使用对象的 hashCode 方法来计算桶下标，因此要将对象添加到这些集合里，必须重写 hashcode 和 equals 方法，不能只重写一个 equals，不然所有 new 出来的对象都判断为不是相等的对象。

3. why? 为什么两个对象有相同的 hashcode 但不一定是相等的？
    - 因为 hashcode 函数是根据对象的内容计算出一个值，极端一点就和一个二次函数一样，输入不同的自变量对应相同的值。所以就要求 hashcode 函数设计的要够随机。

































​    

#### 【关键字 Final】

三种用法：
- 修饰类 表示类不可继承
- 修饰方法 表示方法不能重写
- 修饰变量 表示变量必须被初始化，且初始化后不可更改。


抽象类可否用final修饰？
- 不能，，抽象类就是给别的类继承的，而final修饰的类无法被继承。矛盾 

#### 【重载和重写】Java 重载和重写？

#### 【接口和抽象类】

- 抽象类可以有构造函数，接口没有。
- 抽象类可以有main方法，接口没有。
- 抽象类可以提供一些方法的实现，接口在jdk8以后也可以通过default方法来提供方法的默认实现了。
- 一个类只能继承一个抽象类，但可以实现多个接口。
- 接口方法默认是public的，抽象类中的可以是任何。


#### 【异常】讲讲异常处理？

- 顶层接口是 Throwable
- Throwable 接口下又分为两种异常，
	1. 一个是 **Error** 是 JVM 处理不了的异常，比如 OOM 和 StackOverflow
    2. 一个是 **Exception** 程序可以自己处理的异常，而 Exception 异常又分为受检和非受检异常。
  
    	a) 受检异常如果不 try catch 的话是过不了编译的。比如 IO 操作。如果函数里有**受检异常**操作，是必须要么 try catch 处理，要么 throws 抛出去，
    	  b) 非受检异常是运行时发生的异常，比如除数为 0，空指针异常等等。

































#### 【反射】讲讲反射？

反射主要是用来获取运行时类的全部信息。

类在加载以后会在堆空间中放一个 Class 对象，我们可以通过 Class.forName() 方法通过全类名拿到这个 Class 对象，然后再配合 reflect 包下的 Method Filed Constructor 等方法获取类的全部信息。

优点：
- 可以通过全类名来创建对象实例，通过这一点使用来自外部的用户自定义类，可扩展性更好。
- 虽然平时反射用的不多，但很多框架底层都用了动态代理，动态代理就是基于反射实现的，比如 Spring 里的 AOP。

缺点
- 反射是非常慢的一种操作，并且反射能拿到包括私有属性在内的全部信息，所以也不是很安全。






#### 【泛型】讲讲泛型？

提供了编译时类型安全检测机制，在编译时检测到非法的类型。本质是把类型参数化，所操作的数据类型变成了一个参数传进去了。

泛型方法和泛型类。
- 泛型方法：输入类型不确定，返回类型也不确定，就可以用泛型来实现。
- 泛型类：比如ArrayList类，HashMap类都是泛型类。





### 集合

- [Java 容器](http://www.cyc2018.xyz/Java/Java%20%E5%AE%B9%E5%99%A8.html#%E4%B8%80%E3%80%81%E6%A6%82%E8%A7%88)

#### 【List】

ArrayList：有一个**elementData数组**来实现的，每次add()前会
每次扩容为原来的1.5倍，但线程不安全。

把原始数组复制出来一份快照，我读的时候就读这个快照，写的话就在原始数组上去写，写完之后更新快照即可。




#### 【Map】

### 虚拟机

- [Java 虚拟机](https://cyc2018.github.io/CS-Notes/#/notes/Java%20虚拟机)







#### 【JVM】讲讲 JVM 是干什么的？

- 就是一个能运行字节码的一个虚拟机。
- 屏蔽了操作系统的底层细节。
- JVM 在运行时会单独在内存中划分出一个区域，在这个区域中划分出………………后来d





#### 【JVM 内存】运行时数据区都有什么？分别是干什么的？会有什么异常？

分两块儿讲，线程共有，线程私有。







#### 【对象创建】对象创建的五个步骤、对象分配内存的两种方法？对象的内存布局（对象头里有什么）、对象的两种访问定位方式？

1. 类加载的检查：遇到一条new就开始
2. 分配内存：两种方法，分别对应两种GC方法，指针碰撞和空闲列表法。
3. 初始化零值：把对象的字段都设置为对应的0值。
4. 设置对象头：这个对象对应类的元数据信息的入口指针、对象的哈希、对象的GC分代年龄等。
5. 执行 <init> 方法

两种访问定位（和那个进程通信的消息队列的方法很一样，有个中介或者直接挂在进程的消息队列里）
- 句柄池：对象改变了指针如何变？句柄池的地址是不会变的，直接找句柄池就可以了。
- 直接指针：对象改变了指针如何变？对象指针改变，引用地址也改变。

#### 【堆内存分配策略】内存分配策略？四个？

1. 对象优先在新生代分配
2. 大对象直接进入老年代
3. 长期存活的对象直接进入老年代
4. 对象动态年龄阈值判定

注意：前三个可以直接把对象分配的流程给说一下，就是那张图！

开始分配的时候，先**优先**判断 eden 区是否放得下，放得下的话就分配，放不下就出发 MGC，MGC 后，再次看 Eden 区是否可以放下，如果能放下，分配，放不下就说明**是个大对象**，就看能不能放到old区，放得下放，放不下进行FGC，FGC后再次判断，如果FGC后还放不下，直接OOM。

在YGC的时候，对象每存活一次，对象头里的年龄就加1，当年龄加到一定的程度以后，就会被**晋升到老年代**里。

动态阈值的方法，把新生代的survivor区的对象按年龄从小到大排列，如果**累计到某个年龄**占用的内存超过survivor一半，取该值和默认阈值更小的一个值，超过这个值的放如老年代！



#### 【GC 回收机制】简历上的聊聊垃圾回收机制

- 这个题就是下面所有垃圾题的总和！

- 1. 首先说说垃圾在哪回收，主要进行GC的区域是在堆和方法区。
- 2. 我们要回收垃圾肯定先要标记垃圾，那么符合什么条件的是垃圾呢？（如何判断一个对象的死亡）
- 3. GC的算法，JVM垃圾回收机制用的什么算法，分代收集！根据每个代的不同特点特点进行分代收集！
- 4.GC 垃圾回收机有哪些呢？CMS 和 G1 垃圾回收器（背一下）







#### 【GC 的区域】主要进行 GC 的区域有哪些呢？

1. 堆
2. 方法区



#### 【GC 对象判断】如何判断一个对象是否已经死亡？GC Roots 有什么？

- 引用计数，会发生互相引用。
- 可达性分析 GC Roots
	- 虚拟机栈和本地方法栈中的引用
    - 方法区中静态变量和常量引用的
    - sychronized 持有的对象是 GC roots

#### 【GC 算法】GC 有什么算法？三种算法详细描述，优缺点是什么？

顾名思义类题目！

- 标记清除
	- 第一步：遍历标记
    - 第二步：清除，具体操作就是维护空闲列表！
    - 缺点是：有很多内存碎片，空间利用率不高。
  
- 标记复制
	- 把内存空间分成两个大小相等的块，只使用一个部分
	- gc 时从 gcroots 出发遍历，标记的过程中就把对象从一个区域挪到另一个区域。
    - 优点是：1是效率最高，由于只需要一次遍历，所以其停顿时间只和存活的对象数量有关。2是且没有空间碎片化。
    - 缺点是：需要两倍的空间。
  
- 标记整理
	- 先标记存活对象。
    - 把存活对象都压缩到内存的一端，具体就是只维护一个指针，指针的一边是用过的，一边是没用过的。
	- 优点是：没有碎片化。
    - 缺点是：每次整理十分耗时，停顿时间很长。

- 分代收集算法？
	- 看下一个问题！












#### 【GC 分代收集】堆空间分代收集的话，各个代的对象有什么特点，用什么算法？

- 先点出 JVM 的堆空间为什么要分代收集呢？
	- 因为三个 GC 算法各有千秋，要具体问题具体分析，根据不同代的特点选择不同的 GC 算法。

- 新生代有什么特点？使用什么算法？
	- 新生代的对象大多数都是**朝生夕死**，**存活时间很短**，占内存少，一次 gc 后**留下的对象很少**，而**复制算法只需要一次遍历**，并且其停顿时间只与存活对象的数量有关，所以回收新生代非常适合用复制算法。直接从 eden 区和 from survivor 挪到 to survivor 就可以了，这也就是 MGC 的过程。
    - 复制算法的缺点，也就是需要两倍空间的这个问题，也通过设计两个较小的 survivor 区来克服了。

- 老年代有什么特点？用什么算法？
	- 老年代的对象大，且存活时间很长，回收不频繁，不适合用复制算法，所以用其他两个就可以了。











#### 【GC 回收器】GC 垃圾回收器都有什么？CMS 和 G1 工作原理要能说出来，并行和并发要说明白。

- serial 和 serial old 收集器，适用于单 CPU 的
- parNew 收集器是 serial 的多线程版。
- parallel 和 parellel old，吞吐量优先的收集器，比较适合后台任务。

#### 下面是重头戏：
- CMS
	- 响应时间优先的一个老年代GC收集器，用的是标记清除法，可以用于对系统响应时间要求较高的场景。尽可能缩短 STW 时间。
    - 四个步骤：初始标记（直接相连的）、并发标记（和用户线程一起标记，最耗时的阶段并发做了）、重新标记（修正并发标记期间用户线程运作导致标记变动的那一部分进行标记）、并发清除（和用户线程同时工作，进行标记清除，最耗时的阶段并发做了）
    - 优点，STW 低，只有初始标记的时候STW了；延迟低。
    - 缺点：吞吐量差；标记清除法，有空间碎片，并发清理阶段没有停用户程序，如果等到老年代满了再去GC的话；有可能OOM，所以要到一定阈值就去GC
    

- G1 收集器
	- 在响应时间可控的情况下，尽可能提高吞吐量的收集器。这个收集器老年代和新生代都可以回收。
    - 把一大块儿空间分成了一个个的小的 Region，每个 Region 可以进行单独回收。根据经验记录每个 **Region 的垃圾回收时间** 和 **回收所获得的空间**，维护一个优先级列表，每次根据允许的收集时间，优先收集价值最大的 Region。
    - 回收过程就是：初始标记（标记出和GCroots直接相邻的）、并发标记（和用户线程并发执行，标记剩下的存活对象）、最终标记（修正并发标记过程中，由于用户线程的执行导致的变化）、筛选回收（对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划，只回收一部分的 Region）。
	- **优点**：整体看是标记整理，局部看是标记复制，运行期间并不会产生空间碎片。
    - **可预测的停顿**：用户可以自己选择要求的停顿时间。

















#### 【四种引用类型】四种引用都有什么？应用场景？

强
软
弱
虚

#### 【STW】STW 是什么？SafePoint 是什么？

每日一面 - 什么是 Safepoint？ - 干货满满张哈希的文章 - 知乎
https://zhuanlan.zhihu.com/p/345034354

#### 【内存泄漏】内存泄漏了解吗？哪些操作可能导致内存泄漏？

对象已经不会被使用了但是 gc 不回收，称内存泄漏。

比如单例模式，其生命周期很长，和应用程序一样，如果他持有了外部对象的引用，这个外部对象无法被回收，就内存泄漏了。






#### 【类加载过程】类加载的过程讲讲？

1. 加载：完成三个工作
	- 全类名获取二进制字节流
    - 静态存储结构转换为方法区运行时的数据结构。
    - 在内存中生成一个代表 Class 对象作为方法区访问这些数据的入口！
2. 链接
	- 验证，验证 .class 文件是否正确，比如是否以 CAFEBABE 开头。
    - 准备：给类的静态变量分配内存和设置初始值，static 修饰就是默认值，final static 就是初始化的值。
    - 解析：把常量池内的符号引用替换为直接引用的过程（这个我实话实说也不知道是干啥的，就是背的）

3. 初始化，编译时的 <cinit> 方法，具体就是执行这个方法
  - 为类属性进行赋值操作。
  - <cinit> 是带锁的
  - <cinit> 方法只会在这几种情况执行：
  	- new（新建对象） getstatic（取类的静态字段） putstatic（给类的静态字段赋值） invokestatic（调用类的静态方法）
        - 反射调用的时候会初始化
        - 父类优先初始化
        - 如果一个接口加入 Jdk8 的默认方法和默认字段时，如果其实现类初始化，接口也会初始化

4. class 对象的卸载（三个条件）
	- 所有实例被卸载了
    - 类加载器被卸载了
    - 类在其他地方也没有被引用

  




#### 【类加载器】有几种类加载器？

三种
1. BootStrap：lib包下
2. Extension：lib/ext
3. Applacation：classpath下的也就是用户类
以及自己可以通过继承ClassLoader 来定义类加载器


#### 【双亲委派】双亲委派机制？为什么要用双亲委派机制？

其实双亲委派机制就是在ClassLoader的 loadClass 方法里体现的。

每个类都对应有一个类加载器：
    - 在类加载的时候，loadClass 方法里会首先判断这个类是否已经被加载，如果被加载则返回这个类。
    - 如果没有被加载，则首先委托他的上一级进行类加载，最后所有类加载的请求都会被送到 BootStrap 类加载器那里，如果上级加载器无法加载时，则才会让下级进行处理。


好处：
	- 保证程序的稳定性，可以避免类的重复加载。
    - 保证核心 API 不会被更改，我自己定义一个 String 类也不会被类加载器进行重复加载。


可以修改么？可以，重写 loadClass 方法即可


#### 【GC 参数】你调整过哪些 GC 的参数？

调整过堆的大小。

### 并发

- [Java 并发](http://www.cyc2018.xyz/Java/Java%20%E5%B9%B6%E5%8F%91.html#%E5%81%8F%E5%90%91%E9%94%81)

2021年5月14日 11:43:27 
脑子里要有一条主线！！


学习流程：
1. 在此之前需要先了解 线程的基础，比如创建线程的方法等等。

2. 然后宏观了解 Java 线程安全解决的几个方案。

3. 再从方案中去对比各个方案的实施场景是什么，优缺点是什么？

4. 然后就是 JUC 包






#### 线程基础

##### 线程创建的三种方法

##### 线程池？常用的线程池？阻塞队列默认是什么？最佳实践是什么？

##### 线程状态有什么，如何转换？

##### 阻塞是什么意思？什么操作会导致线程阻塞？CAS 有阻塞吗？

##### Executor、Daemon、Thread.sleep()、Thread.yield()

##### 中断？Executor 中断操作？

##### 线程之间的协作：join()、wait()、notify()、notifyAll()、await()、signal()、signalAll()

##### wait()、await()、sleep() 有什么区别？

#### 线程安全解决方案

##### 1. 用不可变解决线程安全

##### 2. 互斥阻塞同步，也就是加锁的方法：sychronized 和 ReentrantLock，加锁优点缺点？

##### 3. 非阻塞同步，也就是不加锁的方法：CAS 、原子类、ABA 问题、AtomicStampedReference，优点和缺点？

并发的问题，现在还一头雾水，形不成逻辑，还是得先把知识全都整一遍才能有全貌把控！5月底之前，一定解决并发的所有问题！！！！！

疑问：例如阻塞和同步是啥问题，CAS 是阻塞么？自旋操作耗费 CPU ？

##### 4. 不同步方案：栈封闭、ThreadLocal 本地存储、可重入代码块

TreadLocal 有什么用处？实现原理？怎么用？

#### 【sychronized】两种锁

##### 乐观锁？悲观锁？

##### 宏观题：讲讲 sychronized 关键字？

把这个问题下面的四个问题全说了就行了

- 宏观：作用，目的，早期版本是什么？
答：主要用于多线程之间访问资源的同步性的问题，可以修饰方法，修饰代码块，主要目的就是保证方法和代码块儿中在任意时刻只有一个线程在执行。在 Java 早期版本里，这个 sychronized 属于重量级锁，因为 java 的线程会映射到操作系统的原生线程上，如果要进行线程切换，是需要操作系统申请互斥量来完成的，这就牵涉到用户态内核态的转换，效率很低。 所以在 java6 之后，从 JVM 层面对 sychronized 进行大量的优化，比如锁升级策略，由无锁、偏向锁、轻量级锁、重量级锁这么一个升级的过程。

- 使用方法是什么：锁代码块儿、锁实例方法、锁静态方法，引出锁的原理。

- 锁的原理：只说1.6的原理，从而引入锁优化的原理。

- 锁优化原理，分别讲讲偏向锁、自旋锁、重量级锁

- 应用场景：如果本来就知道高并发，那么用 CAS 还是 sychronized 呢？



##### sychronized 用法？

- 1
- 2
- 3

- 直接引出下一个：那么他底层的原理是什么呢？（直接说1.6之前的版本，就是操作系统互斥量，用户态内核态的zhuan'huan）

##### sychronized 底层是怎么实现的？

深入分析Synchronized原理(阿里面试题) - 码农小胖的文章 - 知乎
https://zhuanlan.zhihu.com/p/302654066

csdn剽窃怪：
https://blog.csdn.net/chenssy/article/details/54883355

固定答：
- 先宏观答一下：主要靠的是对对象监视器 monitor 的获取，对 .class 进行反编译可以知道其原理。分两个部分说，一个是同步代码块儿，一个是同步方法。

- 同步代码块的上下会有两个指令，一个是 monitorenter 一个是 monitorexit。
	- 当执行到 monitorenter 时，尝试获取对象监视器，详细过程如下：
		- 如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者；
    	- 如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1；
    	- 如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到 monitor 的进入数为0，再重新尝试获取 monitor 的所有权；

	- 当执行到 monitorexit 时，monitor 进入数减 1，如果进入数减到 0 了，那线程就退出 monitor，不再占有 monitor 了。其他被这个 monitor 阻塞的线程可以尝试获取这个 monitor 的所有权。
  
- 同步方法的话，只是对方法加了一个 ACC_SYNCHRONIZED 标识符，没有本质区别，隐式执行两条指令。

- 总结：两个指令的执行是 JVM 通过调用操作系统的互斥量 mutex 来实现，被阻塞的线程会被挂起、等待重新调度，会导致“**用户态和内核态**”两个态之间来回切换，对性能有很大的影响。
- 直接引出xia'yi'ge：**所以 java6 以后引入了锁优化的机制，和对象头里的 MarkWord 进行配合，形成了锁升级的策略**。
  
    
  
    
  
    
  
    
  
    
  
    




##### sychronized 锁优化机制？偏向锁、轻量级锁、重量级锁、锁粗化、锁消除

固定答：
- sychronized 锁优化：因为 java6 之前，sychronized 都是重量级的锁，只要用 sychronized 都需要向操作系统申请一把大锁给锁上，消耗很多资源。所以 java6 之后就从 JVM 角度引入了一个锁升级的策略。具体就是一个对象在不同的竞争条件下使用不同的加锁策略。分别从 无锁 到 偏向锁 到 轻量级锁 到 重量级锁。
	- 偏向锁状态：因为根据统计结果来讲大多数情况下锁不存在多线程的竞争，而且总是由同一个线程多次获得，引入了偏向锁。偏向锁其实就是把对象头的 MarkWord 里放了一个线程的 id，就代表我拿到这个对象的锁了，在接下来的过程中，这个锁没有被其他的线程访问，则持有偏向锁将永远不需要触发同步，也就是说，偏向锁在资源没有竞争的情况下直接不用进行同步了，连 CAS 操作都没有了，提高了性能。
	- 轻量级锁状态：如果出现了两个线程来竞争锁的话，就会对偏向锁执行撤销，并且升级为自旋锁也就是轻量级锁，这个锁会使用原子的 CAS 操作把当前线程 ID 写到对象的 MarkWord 里，如果成功，表示我竞争到了这把锁，如果失败，则继续自旋获取这把锁。如果自旋超过一定的次数，则升级为重量级锁。
	- 重量级锁状态：其实就是之前提到的，之间上一把大锁，交给操作系统进行调度。

##### sychronized 的偏向锁一定比轻量级锁的效率高吗？

- sychronized 锁优化：因为 java6 之前，sychronized 都是重量级的锁，只要用 sychronized 都需要向操作系统申请一把大锁给锁上，消耗很多资源。所以 java6 之后就从 JVM 角度引入了一个锁升级的策略。具体就是一个对象在不同的竞争条件下使用不同的加锁策略。分别从 无锁 到 偏向锁 到 轻量级锁 到 重量级锁。
	- 偏向锁状态：因为根据统计结果来讲大多数情况下锁不存在多线程的竞争，而且总是由同一个线程多次获得，引入了偏向锁。偏向锁其实就是把对象头的 MarkWord 里放了一个线程的 id，就代表我拿到这个对象的锁了，在接下来的过程中，这个锁没有被其他的线程访问，则持有偏向锁将永远不需要触发同步，也就是说，偏向锁在资源没有竞争的情况下直接不用进行同步了，连 CAS 操作都没有了，提高了性能。
	- 轻量级锁状态：如果出现了两个线程来竞争锁的话，就会对偏向锁执行撤销，并且升级为自旋锁也就是轻量级锁，这个锁会使用原子的 CAS 操作把当前线程 ID 写到对象的 MarkWord 里，如果成功，表示我竞争到了这把锁，如果失败，则继续自旋获取这把锁。如果**自旋**超过一定的次数，则升级为重量级锁。
	- 重量级锁状态：其实就是之前提到的，之间上一把大锁，交给操作系统进行调度。
    
    
    
    
    
    
    
    
    
    

##### 讲讲 Lock 锁？ReentrantLock？源码看过么？

##### sychronized 和 Lock 锁的区别？以及相同点？

#### JUC 包

##### JUC 下的 Lock 锁（上面有，不在这总结了）

##### JUC 下的 AQS 讲讲？CountDownLatch、CyclicBarrier、Semaphore

##### JUC 下的其他组件？FutureTask、BlockingQueue、ForkJoin

##### JUC 原子类讲讲？ 

#### Java 内存模型？

##### Java 的内存模型讲讲？

##### 讲讲 volatile 关键字、用法举两个例子?

- 先说 java 的内存模型是什么？
- 再说 volatile 解决了什么问题？有序性和可见性！
- 单例：禁止重排序，new 指令三个，后两个可乱！
	- 先分配内存空间！
    - 执行 init 方法！
  	- 最后连接引用！
- **shutDownFlag**：周志明 JVM p446，voltaile 保证每次 while 之前进行 load 操作！




##### 字节：为什么要指令重排呢？

在执行程序时为了提高性能，编译器和处理器通常会对指令做重排序：
- 编译器重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序；
- 处理器重排序。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序；

#### 死锁问题

##### 死锁发生的条件？

##### 让你实现一个死锁的例程，你如何实现？

#### 并发集合

##### ConcurrentHashMap 如何实现的，为什么可以解决并发问题？get 操作会加锁么？

##### CopyOnWriteArrayList 底层如何实现？原理？

#### 综合其他问题

https://blog.csdn.net/crazyhuntsman/article/details/82177512

##### sychronized 和 Lock 锁的区别？以及相同点？

##### sychronized 和 volatile 有什么区别？

##### CAS 操作在 JDK 的哪里有应用？

##### 宏观题：你说说这各种同步方式的适用并发场景都是什么？

##### 宏观题：Java 如何实现线程同步？其实线程同步就是为了线程安全，把上面的四种解决方案整明白就可以了。

上锁：sychronized 操作

无锁：CAS 操作

可以再多看看马士兵的视频这块儿。从宏观角度去答这个问题。



##### ConcurrentHashMap 如何实现的，为什么可以解决并发问题？get 操作会加锁么？

##### wait()、await()、sleep() 的区别

https://blog.csdn.net/crazyhuntsman/article/details/82177512

##### 阿里：实现一个线程类，三个线程按顺序打印 ABC

##### 多线程开发良好的实践

给线程起个有意义的名字，这样可以方便找 Bug。

缩小同步范围，从而减少锁争用。例如对于 synchronized，应该尽量使用同步块而不是同步方法。

多用同步工具少用 wait() 和 notify()。首先，CountDownLatch, CyclicBarrier, Semaphore 和 Exchanger 这些同步类简化了编码操作，而用 wait() 和 notify() 很难实现复杂控制流；其次，这些同步类是由最好的企业编写和维护，在后续的 JDK 中还会不断优化和完善。

使用 BlockingQueue 实现生产者消费者问题。

多用并发集合少用同步集合，例如应该使用 ConcurrentHashMap 而不是 Hashtable。

使用本地变量和不可变类来保证线程安全。

使用线程池而不是直接创建线程，这是因为创建线程代价很高，线程池可以有效地利用有限的线程来启动任务。

##### 线程的阻塞和等待状态有什么区别？

##### CyclicBarrier 和 CountdownLatch 区别？

## 操作系统

<!--Note-->
### 资料

- 《现代操作系统》
- 《深入理解计算机系统》
- 《UNIX 环境高级编程》
- 《Unix/Linux 编程实践教程》
- 《鸟哥的 Linux 私房菜》
- 《The Linux Command Line》
<!--/Note-->

### 基础

#### 概述

##### 并发和并行

**并发**：同一段时间交替发生。只不过交替进行的速度非常快，所以在人类能感知的时间尺度上仿佛感觉到这几件事情是同时做的。

**并行**：在同一时刻内发生了。

##### 操作系统是干什么的 / 谈谈你对操作系统的了解？

从宏观来说一下我对操作系统的理解：
1. 首先操作系统也可以认为是一个应用程序，这个程序是为了管理计算机硬件和软件资源的。
2. 他为我们屏蔽了硬件层的复杂性，可以形象的认为成一个中介，来帮我们统筹操纵硬件资源。


再细节一点的说呢：
操作系统可以帮我们完成很多事情，比如
1. 设备管理（开关机）
2. 文件管理（文件系统）
3. 磁盘管理
4. 进程管理（控制、通信）
5. 内存管理


##### 用户态内核态是什么？

用户态和内核态其实就是操作系统的两种运行状态
1. 用户态：在用户态下运行的程序只能直接读取用户程序的数据，并且无法访问外围的设备，且无法独占 CPU。
2. 内核态：内核态运行的程序可以访问计算机任何的数据和资源，不受限制，例如网卡、硬盘等。并且处于内核态的 CPU 可以直接由一个程序切换到另一个程序，不会发生 CPU 抢占的情况。

##### 什么是系统调用？

  在解释系统调用前，需要先简单说明一下内核态和用户态的区分：
  用户态和内核态其实就是操作系统的两种运行状态：
1. 用户态：在用户态下运行的程序只能直接读取用户程序的数据，并且无法访问外围的设备，且无法独占 CPU。
2. 内核态：内核态运行的程序可以访问计算机任何的数据和资源，不受限制，例如网卡、硬盘等。并且处于内核态的 CPU 可以直接由一个程序切换到另一个程序，不会发生 CPU 抢占的情况。


  那么从之前说的这个区别中我们可以了解到，用户程序访问资源的能力有限，一般上比较重要的事情比如从硬盘读数据、从外设中获取输入等等是内核态才能够做的事情。
  因此要做上面提到的这些事情，就要牵涉到一个 **用户态到内核态** 的转换，唯一能做这个转换操作的就是我们说的**系统调用**了


  我了解到的系统调用有这么几种
- 进程控制
	- fork()
    - exit()
    - wait()

- 进程通信	
	- pipe()
    - mmap() 零拷贝的方法，引申，你还知道什么是零拷贝？
  
- 文件操作
	- open()
	- read()
	- write()
  
- 权限操作
	- chmod()




##### 系统调用都有哪些？

- 进程控制
	- fork()
    - exit()
    - wait()

- 进程通信	
	- pipe()
    - mmap() 零拷贝的方法，引申，你还知道什么是零拷贝？
  
- 文件操作
	- open()
	- read()
	- write()
  
- 权限操作
	- chmod()


##### 零拷贝是什么？

#### 进程管理

- 设备管理（开关机）
- 文件管理（文件系统）
- 进程管理（控制、通信）
- 内存管理
- 磁盘管理

##### 进程、线程区别？

从四个方面答：
- 资源分配：点出进程是资源分配的基本单位。一个进程可以拥有多个线程，线自身没有资源但可以访问其隶属进程的资源。
- 执行调度：点出线程是独立调度的基本单位。线程在同一个进程内切换无需引起进程切换。从一个进程中的线程切换到另一个，会引起切换。
- 系统开销：进程的创建和销毁肯定是比线程要消耗的资源多。
- 通信难易程度：同一进程内的线程很容易进行通信，但是进程通信就需要借助一些其他的手段。




##### PCB 是什么？有什么作用？

PCB 就是进程控制块，其实就是描述进程的一些信息。
1. 进程的描述信息，比如进程的名称，标识符，
2. 处理机的状态信息，当程序中断是保留此时的信息，以便 CPU 返回时能从断点执行
3. 进程调度信息，比如阻塞原因，状态，优先级等等
4. 进程控制和资源占用，同步通信机制，链接指针（指向队列中下一个进程的 PCB 地址）


PCB 作用？
- PCB是进程的一部分，是十分重要的数据结构。
- 正是因为 PCB，使不能独立运行的程序成为一个个能独立运行的基本单位，有了并发执行的能力。
- 再一个是 PCB 是进程是否存在的唯一标识，操作系统就是靠 PCB 来感知进程的存在的。







##### TCB 是什么？有什么作用？

  和 PCB 相似的线程控制块儿，只是TCB中所保存的线程状态比PCB中保存少而已。

  我没有具体了解过，只知道他是线程的唯一标识。但我对 PCB 了解的比较多，可以详细说一下 PCB 吗？







##### 进程创建和销毁时会发生什么事？

创建：
1. 申请空白的PCB
2. 初始化进程描述信息
3. 为进程分配资源以及地址空间
4. 将其插入就绪队列中


销毁：
1. 查找需要撤销的进程的 PCB
2. 如果进程处于运行状态，终止进程并进行调度
3. 终止子孙进程 - 归还资源
4. 将它从所在的就绪队列中移除


##### 线程创建和销毁时会发生什么事？





##### 进程五种状态

1. 有创建状态、就绪状态、运行状态、阻塞状态、结束状态。
2. 其中只有**就绪状态**和**运行状态**能互相转化
3. 当进程为**就绪状态**时，会等待 CPU 分配时间片，得到时间片后就进入**运行状态**
4. **运行状态**在使用完 CPU 时间片后，又重回**就绪状态**。
5. **阻塞状态**是进程在**运行状态**时，需要等待某个资源。比如打印机资源，而进入一个**挂起**的状态，等资源拿到后会回到**就绪状态**，等待 CPU 时间片。

##### 进程调度算法

两种回答：
- 批处理系统，类似打印机
	- FCFS（first comed first served）
    - SJF（short job first）
    - SRTN（short remaining time first ）


- 交互系统，要求实时性强
	- 时间片轮转：每个进程分配相同的时间片。
    - 优先级调度：先调度优先级高的。
    - 多级反馈队列（时间片轮转和优先级调度的结合）



##### 进程同步四种方式

1. 临界区
对临界资源的访问那段代码被称为临界区，为了互斥的访问临界区，每个进程在进入临界区时，都需要先进行检查，也就是查看锁。

2. 同步与互斥
- 同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后顺序。
- 互斥：多个进程在同一时刻只有一个进程能进入临界区。

3. 信号量
    信号量是一个整型变量，可以对其执行 P 和 V 操作。
    P：如果信号量大于零，就对其进行减 1 操作；如果信号量等于 0，进程进入 waiting 状态，等待信号量大于零。
    V：对信号量执行加 1 操作，并唤醒正在 waiting 的进程

  如果信号量只能取 0 或者 1，那么就变成了互斥量，其实也可以理解成加锁解锁操作，0 表示已经加锁，1 表示解锁。

4. 管程
    了解的不多，只知道有一个重要特性：
    在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。
    管程提供了 wait() 和 signal() 操作来实现同步操作，wait() 操作会阻塞进程，释放管程，signal() 会唤醒进入阻塞状态的进程，重新占用管程。




##### 进程通信的五种方式

1. 管道
  1.1 匿名管道
    举个例子：linux 里的竖线，就是管道的意思，有这么几个特点
- 这种通信的方式是半双工通信的，只能单向交替传输
- 并且只能在具有亲属关系的进程之间通信使用。
- 可以看成是一种特殊的文件，但是这种文件只能存在于内存之中。

1.2 命名管道
  可以用 mkfifo 命令创建一个命名管道，可以用一个进程向管道里写数据，然后可以让另一个进程把里面的数据读出来。
- 命名管道，去除了只能在父子进程中使用的限制。
- 命名管道有路径名和它相关联，也可以认为是一种特殊设备文件形式存在于文件系统中。


2. 消息队列
    消息队列的通信模式是这样的：a 进程要给 b 进程发消息，只需要把消息挂在消息队列（可以是中介邮局，也可以是进程自己的信箱）里就行了，b 进程需要的时候再去取消息队列里的消息。
- 消息队列可以独立于读写进程存在，就算进程终止时，消息队列的内容也不会被删除。
- 读进程可以根据消息类型有选择的接收消息，而不像 FIFO 那样只能默认接收。
- 但是如果进程发送的数据较大，并且两个进程通信非常频繁的话，消息队列模型就不太合适了，因为如果发送的数据很大的话，意味着发送消息（拷贝）这个过程就需要很多时间来读写内存。


3. 共享内存
    共享内存的方式就可以解决拷贝耗时很长的问题了。
    要解释共享内存这块儿就需要简单提一下虚拟内存的概念：系统加载一个进程的时候，分配给进程的内存并不是实际的物理内存，而是虚拟内存空间。那么我们可以让两个进程各自拿出一块儿虚拟地址空间来，映射到同一个物理内存中。这样两个进程虽然有独立的虚拟内存空间，但有一部分是映射到相同的物理内存，这样就完成共享机制了。
- 共享内存是**最快**的一种进程通信的方式，因为进程是直接对内存进行存取的。
- 因为可以多个进程对共享内存同时操作，所以对共享空间的访问必须要求进程对共享内存的访问是互斥的。
- 共享内存经常和信号量一起使用来实现进程通信。

4. 信号量
    共享内存最大的问题就是多进程竞争内存的问题，就像平时所说的线程安全的问题，那么就需要靠信号量来保证进程间的操作的同步与互斥。
    信号量其实就是个计数器，例如信号量的初始值是 1，然后 a 进程访问临界资源的时候，把信号量设置为 0，然后进程 b 也要访问临界资源的时候，发现信号量是 0，就知道已有进程在访问临界资源了，这时进程 b 就访问不了了，所以说信号量也是进程间的一种通信方式。


5. 套接字
套接字可以实现两个不同的机器之间的进程通信，比如 socket 使用。




##### 生产者消费者模型？

  生产者和消费者模型，期间就需要线程之间进行通信来实现互斥和同步。
  首先需求是这样的：
1. 生产者每生成一个产品，就消耗一个缓冲区，只有当缓冲区不满的时候才能放入；
2. 消费者每消费一个产品，就消耗一个产品，只有当缓冲区不空的时候才能消费。
3. 因为缓冲区是临界资源，所以需要定义一个互斥信号量，为 mutex 来实现两者对临界资源的互斥访问。
4. 为了同步生产者和消费者的操作，需要记录缓冲区的剩余大小 empty 和 产品的个数 full。当缓冲区大小不为 0 时，生产者才能放入产品；当产品个数不为 0 时，消费者才能拿走产品。



不能调换上锁的顺序！
- 而如果生产者先对临界区上锁，就可能会发生死锁，举个简单例子：
1. 首先，生产者此时先对**临界区**加锁，然后发现**缓冲区**已满，就开始进入阻塞等待消费者消费产品的状态。
2. 然后，此时一个消费者开始进入消耗一个产品，但发现**临界区**被加锁，就是开始阻塞等待生产者释放**临界区**。
3. 这时就形成死锁：生产者在等待消费者**消费产品**，而消费者在等待生产者**释放临界区锁**，进入了一个死锁状态。


```java
mutex = 1;
empty = N;
full = 0;

void Producer() {
    P(empty); // 生产者生产一个产品，消耗一个缓冲区 
    P(mutex);
    ....      // 临界区
    V(mutex);
    V(full); // 产品数量加1
}

void Consumer() {
    P(full); // 消费者消耗一个产品，释放一个缓冲区
    P(mutex); // 临界区上锁
    ....
    V(mutex); // 临界区锁释放
    V(empty); // 增加一个缓冲区
}


void P(S){
    S--;
    if(S < 0) block();  // 如果小于0，代表资源没了
}

void V(S){
    S++;
    if(S <= 0) wakeUp(); // 如果小于等于0，代表有进程仍然在等待，通知他们ok了
}
```


















##### 线程实现方式

？？？

##### 协程

我只知道是一种轻量级的运行在用户态上的线程，一个线程可以拥有多个协程，无需线程上下文切换的开销，别的就不知道了。

#### 死锁

##### 死锁产生的四个条件

- 互斥条件:是资源分配是互斥的，资源要么处于被分配给一个进程的状态，要么就是可用状态。
- 占有和等待条件：进程在请求资源得不到满足的时候，进入阻塞等待状态，且不释放已占有的资源。
- 不剥夺条件：已经分配给一个进程的资源不能强制性地被抢占，只能等待占有他的进程释放。
- 环路等待条件：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程释放所占有的资源。

##### 如何预防死锁？如果发生死锁如何解决？

首先要尽量避免死锁的发生，可以从两个角度考虑。
- 预防策略
	- 破坏互斥条件
    - 破坏占有和等待条件
    - 破坏不剥夺条件
    - 破坏环路的等待条件
- 死锁避免算法
	- 银行家算法的描述！
    	1. 某个进程对某个资源提出申请时，判断该请求是否会使得系统进入不安全状态，如果是，就拒绝请求，否则再对其进行分配。
        2. 安全状态的定义就是，在没有死锁发生时，所有进程突然对某个资源提出最大需求，也仍然存在某种调度次序能够使一个进程运行完毕，则称这个状态是安全的。
    
    

如果真的发生死锁，也有解决策略：
- 首先需要检测死锁，检测有向图中是否存在环。

- 死锁恢复（从下到上逐渐变态苛刻）
	- 撤销进程
    	- 撤销所有死锁的进程
        - 逐个撤销陷入死锁的进程
    - 资源剥夺策略
    	- 从陷于死锁的进程中逐个强迫放弃所占用的资源，直到死锁消失
        - 从另外的进程强行剥夺资源分配给死锁进程
	- 鸵鸟策略
		- 直接不管了







##### 写出和分析死锁的 Java 代码 或 生产者消费者代码

- 生产者消费者，我们有一个缓冲区也有一个临界区，无论生产者还是消费者，按正确的逻辑都应该是先检查缓冲区，再对临界区上锁。

- 而如果生产者先对临界区上锁，就可能会发生死锁，举个简单例子：
1. 首先，生产者此时先对**临界区**加锁，然后发现**缓冲区**已满，就开始进入阻塞等待消费者消费产品的状态。
2. 然后，此时一个消费者开始进入消耗一个产品，但发现**临界区**被加锁，就是开始阻塞等待生产者释放**临界区**。
3. 这时就形成死锁：生产者在等待消费者**消费产品**，而消费者在等待生产者**释放临界区锁**，进入了一个死锁状态。



```C
mutex = 1;
empty = N;
full = 0;

void Producer() {
    P(empty); // 生产者生产一个产品，消耗一个缓冲区 
    P(mutex);
    ....      // 临界区
    V(mutex);
    V(full); // 产品数量加1
}

void Consumer() {
    P(full); // 消费者消耗一个产品，释放一个缓冲区
    P(mutex); // 临界区上锁
    ....
    V(mutex); // 临界区锁释放
    V(empty); // 增加一个缓冲区
}


void P(S){
    S--;
    if(S < 0) block();  // 如果小于0，代表资源没了
}

void V(S){
    S++;
    if(S <= 0) wakeUp(); // 如果小于等于0，代表有进程仍然在等待，通知他们ok了
}
```

注意！不可对临界区先加锁，设想这样一个情况：
1. 首先，当 empty = 0 时，生产者此时先对临界区加锁，然后发现缓冲区的数量为 0，就开始进入阻塞等待消费者消费的状态。
2. 然后，此时一个消费者开始进入消耗一个产品，但发现临界区被加锁，就是开始阻塞等待生产者释放临界区。
3. 这时就形成死锁：生产者在等待消费者消费产品，而消费者在等待生产者释放临界区锁，进入了一个死锁状态。







```

##### 数据库和 Java 中如何避免死锁

？

#### 内存管理

##### 内存管理有哪四个功能？

内存分配
内存回收
地址映射
内存保护

##### 内存管理的两大种机制？连续 / 非连续

连续：分块儿：每个进程分个块儿，容易造成碎片

不连续：
	- 分页：分层大小相等的页
    - 分段：有意义的段
    - 段页：每个段内不连续



##### 分页和分段有什么区别？

- 都是离散管理的

- 分页的页面大小是固定的，分段不固定。

- 分页没意义，分段有意义。

- 分页内存利用率高，分段难以分配大的连续内存。






##### 分页管理的快表和多级页表是干什么的？

快表：
why？
  首先快表的引入是为了加快逻辑地址到物理地址的访问速度的，在引入快表之前，由逻辑地址访问到内存的过程是这样的：
1. 首先根据逻辑地址的高位拿到页号
2. 根据页号访问内存中页表，根据页表的映射拿到实际的内存块儿号。（一次访问）
4. 把内存块儿号和逻辑地址的低位拼接，得到物理地址
5. 访问对应的内存物理地址。（二次访问）

  这样是需要有**两次**直接访问内存的过程的，所以为了加快这个速度，引入了快表，快表可以认为是一个 Cache，内容是页表的一部分或者全部内容。和页表的功能是一样的，只不过比在内存中的页表的访问速度要快很多。

how? 
  根据局部性原理，被访问后的内存块儿很可能在短时间内再次被访问，所以程序在一段时间内有很大几率会多次访问同一个页表项。所以在每次访问页表项时，先在快表里查询是否有该页表项，如果没有再去页表中查询，并把查到的页表项放入快表。
  如果快表满了，就根据一些策略把里面的页表项淘汰掉，再把新查询的页表加入进去。


多级页表：
why？
多级页表主要是为了解决页表在内存中占用空间太大的问题的，典型的时间换空间的这么一个操作。

我举个简单的例子吧：
- 原来虚拟地址空间是 4GB，如果页的大小是 4KB 的话，需要 4G 除以 4K，也就是 1M 个页表项来映射这么多页，一个页表项一般是 4字节 的大小，这样的话就需要 4MB 的内存空间来存放这些页表项，换算过来就是 1 个页来存放。

- 而引入多级页表以后，我一个一级页表项可以映射的大一点，映射 4MB 的内存，这样只需要 1K 个页表项来映射主内存，然后每个一级页表项再映射 1K 个二级页表项，每个二级页表项再映射 4KB 的内存。

- 当我使用到哪个一级页表项时，再把对应的二级页表项 load 到内存里。



##### 虚拟地址和物理地址？为什么要有虚拟地址？

what?
什么是虚拟地址呢？
  我们在写程序的时候打交道的都是虚拟地址，比如 C 语言的指针，这个虚拟地址由操作系统决定，
  而物理地址指的是真实内存地址寄存器的地址。
  处理器通常使用虚拟寻址，用 MMU 把虚拟地址翻译成物理地址才能访问到真正的物理地址。
  
  
why?
为什么要有虚拟地址这种东西呢？
- 如果直接操作物理地址，用户程序可以直接访问底层物理地址，很容易破坏操作系统，造成系统崩溃。
- 想要同时运行多个程序很难，多个程序可能对同一个物理地址进行操作，发生崩溃。


##### 虚拟内存是什么？

why？
  为什么要有虚拟内存这种技术呢？
  因为传统的内存管理有这么两个特点：
1. 一次性：程序运行时把所有的作业都 load 到内存里
2. 驻留：这些程序和数据会一直驻留到运行结束

  这样也会带来两个问题：
1. 一些比较大的作业是没有办法一次性装入内存的，比如一个 GTA5 就几十个G，不可能一次性装内存里的。
2. 装入内存的数据和程序就算没有被使用，也会一直占有内存，直到被释放



how?
  虚拟内存的实现思路是什么？
1. 在一段时间内只需要少部分数据就可以保证程序的正常运行。
2. 所以在程序运行的开始，只把少部分很快就要用到的程序和数据 load 到内存里，暂时用不到的部分放在外存里。
3. 如果在运行过程中发生缺页，就从外存调入要用到的页面。
4. 如果调页的时候发现内存满了，就根据一些策略把不用的页调出去。
5. 而在 os 的管理下，让程序认为自己拥有连续可用的内存，产生独享主存的错觉，这就是虚拟内存。




##### 虚拟内存的实现方式？

按照虚拟内存的作用，操作系统有这么 3 种方法来实现虚拟内存：
1. 请求分页式管理
2. 请求分段式管理
3. 请求段页式管理

其实这些实现方法看着和操作系统的内存管理机制有一些一样，其实最大的区别在于（这里拿请求分页式来举个例子）：
1. 我理解请求分页式存储管理建立在分页管理之上
2. 他们最最根本区别是用不用把程序所需的**全部的程序和数据** load 到内存里。请求分页式不需要全部 load 到内存中，而分页式管理需要。
3. 再一个就是，请求分页式管理是能够为程序提供虚拟内存的，后者是提供不了的！

##### 页面置换算法

FIFO
LRU
LFU

##### 局部性原理？

时间局部性原理：如果程序中一条指令一旦执行，不就以后该指令就很有可能再次执行；如果某数据被访问过，不就以后该数据很可能再次被访问。原因是存在大量循环。

空间局部性原理：一旦程序访问了某个存储单元，在不就之后，其附近的存储单元也将被访问，即在一段时间内程序所访问的地址通常集中在一个范围内。因为指令通常时顺序存放、顺序执行的。

操作系统的很多实现的理论基础都是局部性原理，
- 比如虚拟内存
- 比如快表、多级页表

##### 静态链接与动态链接

？？？

### Linux

#### 文件系统

- 从文件系统的角度分析数据恢复原理

##### 硬链接与软链接

快捷方式

#### 进程管理

- 能够使用常用的命令，比如 cat 文件内容查看、find 搜索文件，以及 cut、sort 等管线命令。了解 grep 和 awk 的作用。

##### 僵尸进程与孤儿进程

僵尸进程与孤儿进程的区别，从 SIGCHLD 分析产生僵尸进程的原因。

#### 常用命令

- 能够使用常用的命令，比如 cat 文件内容查看、find 搜索文件，以及 cut、sort 等管线命令。了解 grep 和 awk 的作用。

##### 目录操作命令

##### 文件查看命令

##### 进程管理命令

文档：14. Linux 进程管理.note
链接：http://note.youdao.com/noteshare?id=8d34aad067847a3430a7534a6f91e408&sub=8C5F90176E1142A385F7E714F699BB23

- ps
	- aux
    - l
    - ef
- pstree
	- apu
- top
	- d 2
- netstat
	- anp | grep port



##### 权限管理命令

#### 其他重要知识

- 能够使用常用的命令，比如 cat 文件内容查看、find 搜索文件，以及 cut、sort 等管线命令。了解 grep 和 awk 的作用。

##### I/O 模型

http://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Socket/Socket.html

##### 多路复用

http://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Socket/Socket.html

## 计算机网路

<!--Note-->
### 资料

- 《计算机网络 自顶向下方法》
- 《计算机网络》
- 《TCP/IP 详解 卷 1：协议》
- 《UNIX 网络编程 卷 1：套接字联网 API》
- 《Linux 多线程服务端编程》
- 《图解 HTTP》
<!--/Note-->

### 网络基础

- [计算机网络](https://cyc2018.github.io/CS-Notes/#/notes/计算机网络)

#### OSI 体系

##### OSI 七层、TCPIP 五层、各层之间如何提供服务？

应用层：
- 横向看的话：是为应用程序间提供通信和交互的协议。
- 主要协议有 DNS、HTTP、SMTP 等。
- 这一层的数据称为：报文。

传输层：
- 横向看的话：是为两台主机中的进程间提供通用的数据传输服务。
- 纵向看：为上层提供的服务，把应用层的报文封装成 TCP 的报文段或 UDP 的用户数据报进行传送。
- 主要协议有 TCP、UDP

网络层
- 横向看的话：为两台主机提供通信服务。
- 纵向看：为上层提供的服务，把运输层产生的报文段或用户数据报封装成 IP 数据报进行传送。
- 主要协议有 ARP、ICMP

数据链路层
- 横向看的话：还是为两台主机之间的数据传输提供服务，两台主机之间的传输，总是在一段一段的链路上传送的，就需要链路层的协议。
- 纵向看：为上层提供的服务，把 IP 数据报封装成帧，在链路上进行传递。
- 主要协议有 CSMA PPP

物理层：
- 横向看的话：在传输媒体上进行传输比特流。
- 纵向看：为上层提供的服务，尽可能为数据链路层屏蔽传输媒体和通信手段的差异，把帧拆分成比特流在传输媒介上进行传输。
- 主要协议有 时分复用、频分、码分多址、波分复用等！









##### 以太网

##### 路由器的作用

路由器在网络层：
其基本功能是，把数据（IP 报文）传送到正确的网络。细分则包含：


1. IP 数据报的转发。包含数据报的寻径和传送；
2. 子网隔离。抑制广播风暴。
3. 维护路由表，并与其他路由器交换路由信息，这是 IP 报文转发的基础。
4. IP 数据报的差错处理及简单的拥塞控制；
5. 实现对 IP 数据报的过滤和记帐。


#### 网络层

##### IP 地址

- 几种类型？
- 子网掩码是干什么的？
- 如何判断两个IP地址属于同一个子网？

##### IP 数据报

- IP 数据报首部都有什么信息
	- 版本号：放ipv4还是ipv6
    - 生存时间
    - 本次的数据上交给哪个协议进行处理？
    - ……………… 别的就忘了

##### ARP 协议

  ARP 这个协议主要提供了由目的 IP 地址得到目的 MAC 地址的功能。

  因为网络层讲的是 主机和主机 之间的通信，分两种情况：
1. 在同一个局域网中
  主机 A 想往主机 B 发信息时，会先在自己的 ARP 缓存表中查找是否有对应 主机B IP 地址的 MAC 地址，如果没有，则发送一次 广播 ARP 请求分组，主机 B 和主机 A 在同一个局域网，则主机 B 收到 ARP 请求分组时，会回发一个 ARP 响应分组，里面带有自己的 MAC 地址。

2. 不在同一个局域网中
  主机 A 会先把子网掩码和目的 IP 进行相与，发现不一个网段，那么其下一跳就直接找默认网关就可以了，如果 ARP 缓存里没有默认网关的 MAC 地址，也需要先发一个 ARP 请求分组，等默认网关给他回一个 ARP 响应分组后，就拿到了默认网关的 MAC 地址。
  路由器会帮他广播，找到主机 B 的 MAC 地址，然后主机 B 会回答一个 ARP 响应分组给 主机 A 然后就拿到了！

##### ICMP 协议

what?
  本质还是个 IP 数据报，IP数据报的**数据段**用 ICMP 报文代替了而已。

why? 
  ICMP 是网络层的协议，主要作用是用来提高交付成功的机会，让网络中的节点能够报告**差错情况**和**异常情况**。


- 差错报文的四种类型
	- 终点不可达报文：当路由器和主机没办法交付数据，就向源头发送一个终点不可达报文。
    - 时间超过报文：如果路由器发现数据的 TTL 为 0，那么丢弃该数据，并向源头发送一个时间超过报文。
    - 参数问题报文：如果路由器或主机发现 IP 数据报的首部有错误时，就告诉发给源头一个参数问题报文。
    - 改变路由报文：路由器给主机发送这个报文，告诉他有更好的路径。
    
- 询问报文的两种作用
	- echo（ping 命令）：请求报文或回答报文：主机或路由器向一个特定的主机发送回声请求报文，目的主机收到后回一个回答报文。
    - 时间戳请求：时间戳请求和回答报文：向服务器请求一个时间戳，用来时钟同步和测时间。



#### 传输层

##### UDP 和 TCP 区别？

1. 有无连接？
  UDP 无连接。
  TCP 有连接。
  
2. 拥塞控制？
  UDP 无拥塞控制
  TCP 有拥塞控制
  
3. n对n？
  UDP 可以1对n
  TCP 只能1对1

4. 是否拆分数据？传输数据大小？
  UDP 不拆分数据，直接把数据拿下来，加上一个 UDP 头，就转交给了下一层。
  TCP 要把数据拆分成适合传输的大小再传输。



##### UDP 和 TCP 的应用场景？

实时音视频：UDP 实现

有延迟的网络直播：TCP


##### 让你设计一个可靠的 UDP 你如何设计？

  主要从 UDP 的缺点来考虑，首先 UDP 是尽最大可能交付的协议，只管发，收不收的到，收到的包完整不完整就和发送方没关系了。
  所以从以下几个方面来考虑：
1. UDP 发送数据不保证完整性 –> 加上 CRC 验证字段
2. UDP 连续发送几个包有可能是乱序到达的 –> 加上一个数据包序列号 SEQ
3. UDP 发送数据有可能会丢包 –> 需要确认和重传机制，就是和 Tcp 类似的 Ack 机制

##### TCP 连接，三次握手、为什么三次握手

1. 三次握手的过程：
客户端的连接请求：首先客户端发送一个带 SYN 标志位的连接请求到服务器，客户端进入 SYN-SENT 状态。
服务端的连接确认请求：服务器收到之后回复一个 SYN 和 ACK 的确认报文到客户端，此时服务端进入 SYN-RECV 状态，等待第三次握手。
客户端的连接确认请求：客户端接收到确认报文后，向服务端再次发出带 ACK 的确认报文，后客户端这边连接建立，服务端收到客户端的第三次确认报文后，连接建立。

2. 为何要三次握手？
    **从第一个角度**。通信是双方的行为，双方都需要确认四件事，自身的接收发送是否正常以及对方的接收发送是否正常。如果仅两次的话，服务端是没有办法确认自己发送和对方接收是否正常的，不是可靠的连接。
    **从第二个角度**。也可以防止失效连接到达服务器后重新打开连接。客户端发送的请求如果阻塞。那么客户端等待一个超时重传时间以后，会重发一个连接请求。假设这个来迟滞留的请求最终到达了服务器，如果不三次握手的话，服务器就会打开两个连接。如果有第三次握手，客户端就会忽略掉服务器之后的连接确认请求。
    

3. 如果 1、2、3 次握手分别丢包了，会发生什么？
https://blog.csdn.net/plokmju88/article/details/103884145
第一次客户端发的 SYN 丢了：
客户端迟迟接不到响应，超时重传。
第二次服务端发的 SYN 和 ACK 丢了
客户端迟迟接不到响应，超时重传
第三次客户端发的 ACK 丢了？
因为第三次发完 ACK 之后，随时接下来会继续往服务端发数据，我看过一篇博客里写的是发数据时会带上 ACK，所以客户端响应的 ACK 包丢了，服务器也能够通过之后的包来建立连接。
第三次故意不发送 ACK 呢？
洪水攻击，服务器在等待第三次握手时是处于半连接状态，也是需要耗费资源的，如果有攻击者故意不发送第三次 ACK，让大量连接处于半连接状态，那么会把服务器资源耗尽，洪水攻击的目的就达到了。






















##### TCP 连接四次挥手、为什么四次挥手、为什么等待2MSL时间？

1. 四次挥手的过程
客户端发送一个带 FIN 标志位的关闭连接请求，此时客户端进入 FIN - WAIT - 1 阶段。

服务器收到该请求后，返回一个 ACK。
客户端收到 ACK 之后，进入 FIN - WAIT - 2 阶段，此时处于半关闭状态，服务器能给客户端发消息，但客户端不能给服务器发消息。

当服务器把剩下的消息发完之后，会发送一个 带 FIN 标志位的关闭连接请求给客户端。

客户端收到该请求后，发出 ACK 确认，并进入最后的 TIME - WAIT 状态，等待 2MSL（最大报文存活时间） 后释放连接。
B 收到确认后，释放连接。


2. 四次挥手的原因
服务端在收到客户端的 FIN 报文后，仅表示客户端不在发送数据了，但客户端还可以接，而服务端也不是说数据都发完了，所以服务端可以立即关闭，也可以再发送一段时间的数据后再发送 FIN 报文给客户端表示同意关闭。因此服务端的 ACK 和 FIN 标志位会分开发送，在 ACK 和 FIN 之间可能还会给客户端传数据，导致多了一次。


3. 为什么客户端要等待 2MSL 后再释放连接
- **第一个角度**：确保最后一个确认报文能到达，如果服务器没收到来自客户端的 ACK 报文，就会重新发送 FIN 报文到客户端，客户端等待一段时间就是为了处理这种延迟的情况。
- **第二个角度**：等待一段时间是为了让本连接持续的时间内所有报文从网络中消失，使得下一个新连接里不会出现旧的报文。


























##### TCP 连接，三次握手期间丢包分别会发生什么事情？SYN FLOOD 是什么意思？

https://blog.csdn.net/plokmju88/article/details/103884145
- 第一次客户端发的 SYN 丢了：
	- 客户端迟迟接不到响应，超时重传。
- 第二次服务端发的 SYN 和 ACK 丢了
	- 客户端迟迟接不到响应，超时重传
- 第三次客户端发的 ACK 丢了？
	- 因为第三次发完 ACK 之后，随时接下来会继续往服务端发数据，我看过一篇博客里写的是发数据时会带上 ACK，所以客户端响应的 ACK 包丢了，服务器也能够通过之后的包来建立连接。
- 故意不发送第三次 ACK 呢？
	- 洪水攻击，服务器在等待第三次握手时是处于半连接状态（SYN_RCVD），也是需要耗费资源的，如果有攻击者故意不发送第三次 ACK，让大量连接处于半连接状态，那么会把服务器资源耗尽，洪水攻击的目的就达到了。
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

##### TCP 可靠传输是如何实现的？

问：TCP 是如何实现可靠传输的？
答：首先可靠传输的基础是滑动窗口协议，配合着一些其他的控制来使得整个传输过程可靠。这些控制我觉得可以按分为三部分去解释，一个是基本的控制、一个是发送端的控制、一个是接收端的控制。

1. 首先详细说一下滑动窗口协议：
- 首先在发送方和接收方都维护一个滑动窗口，发送方的窗口大小其实是由接收方的响应报文里的一个字段控制的。

- 发送方：窗内都允许被发送，窗内最左侧的字节如果已发送并且被确认，向右滑动，直到第一个不是被确认状态的字节。

- 接收方：窗内都允许被接收，窗内最左侧的字节如果已接收，向右滑动到第一个不是已接收的状态的字节。并且最重要的是，接收方仅对最后一个按序到达的字节进行确认！


2. 然后说一下这些控制，从三个方面来讲
**基本的控制**：
- 把应用层的数据拆分成适合传输的一个个块儿。
- 并且给发送的每一个块儿进行编号，在接收端对数据包进行重排。

**发送端的控制**：
- 超时重传技术（两个公式细节在下面）：当发送方发送一个包时，启动一个定时器，等待确认这个包，如果不能在阈值内收到确认这个包，则重发。

- 流量控制：为了控制发送方发送速率，保证接收方来得及接收。接收端返回的确认报文中的窗口字段可以控制发送窗口大小，从而影响发送方的速率。将窗口字段设置为 0，则不能发送数据。

- 拥塞控制（有四个算法）：当网络拥塞时，会丢包，此时发送方会不断尝试重传，从而导致拥塞程度更高。因此当出现拥塞时，应当限制发送方的发送速率。和流量控制很像但目的不同。流量控制更多的是一个端到端的控制，要做的是抑制发送端发送数据的速率，主要是为了控制接收方来得及接。而拥塞控制是为了宏观上降低网络的拥塞程度。

**接收端的控制**：
- 校验和：保证首部的数据的校验和。如何校验和有误，那么就丢弃该数据包，且不发送确认消息。
- 丢弃重复：如果收到重复的数据包，直接丢弃。






























##### TCP 为什么要有心跳检测？具体怎么操作的？

https://blog.csdn.net/m0_47984232/article/details/108253344

#### 应用层

##### DNS

  DNS 是域名解析协议，提供了域名和 IP 地址之间相互转换的服务。

  **域名解析请求**一般上是用的 UDP 协议，因为 UDP 快，只需要一个请求，一个响应就够了。

  而**区域传送**，也就是**同步主DNS服务器**时，肯定是用 TCP，因为要保证这正确性。
  
  

##### DHCP 协议

知道是干什么的就行了

- 为用户提供即插即用的联网方式，不需要手动配置IP地址信息。
- 自动为用户配置 IP、子网掩码、网关




##### 其他协议

FTP、SMTP、POP3、IMAP

#### 综合问题

##### 敲击 URL 后发生了什么

http://www.scr2019.top/blog/12

**简略版**：
  1. 键盘敲下来的那一刻，浏览器是想生成TCP套接字，向Http服务器发请求的。
  2. 为了生成 TCP 套接字，需要知道域名对应的 IP 地址
  3. 为了知道域名的 IP 地址，需要向 DNS 服务器发送 DNS 查询报文。
  4. 为了向 DNS 服务器发送 DNS 查询报文，需要知道自己默认网关的 MAC 地址。
  5. 为了知道我默认网关的 MAC 地址，需要用 ARP 协议解析出下一跳，也就是默认网关的 MAC 地址是什么。


**详细版**：
1. ARP 解析 MAC 地址
  首先我 URL 敲下的那一瞬间，浏览器是想生成一个 TCP 套接字用来向这个域名对应的 HTTP 服务器去请求资源的。
  但生成 TCP 套接字需要知道域名对应的 IP 地址，那么浏览器就会先在缓存里找（浏览器缓存，路由器缓存）如果都没有的话就得去 DNS 服务器找了。
  让 DNS 服务器帮忙把域名解析成 IP 地址，需要生成一个 DNS 查询报文，欲把报文交付到 DNS 服务器上。
这个过程需要把该报文封装在帧里发到网关路由器，这时就要求知道网关路由器，也就是“下一跳”的 MAC 地址了，会先从 ARP 缓存表里找，如果没有就需要发送广播 ARP 请求分组，路由器收到请求后，会把自己的 MAC 地址返回给主机。
  以上就是需要先用 ARP 解析网关的 MAC 地址的过程。
  
2. DNS 解析域名
  知道了网关的 MAC 地址后，就可以继续 DNS 解析的过程了。
  封装一个 DNS 查询报文，向 DNS 发送查询请求。
  DNS 服务器收到查询请求后，把查询的结果封装在 UDP 的用户数据报中，返回给主机。
  
3. HTTP 请求页面
  终于拿到了 HTTP 服务器的 IP 地址，主机就能根据 IP 地址生成 TCP 套接字，该套接字将用于向 HTTP 服务器发送 HTTP GET 报文。
  在生成 TCP 套接字之前，需要先进行 TCP 三次握手的连接。
  三次握手建立连接后，浏览器生成 HTTP GET 报文，交付到 HTTP 服务器。
  HTTP 服务器收到请求后，封装一个 HTTP 响应报文，把 Web 资源放进去，返回给主机。
  主机收到 Web 资源后，进行渲染，显示 Web 页面。



### HTTP

- 概念你都说不出来？注意，协议就是为了传信息的，和OSI七层架构一样，只需要把**横向看**的概念说出来就ok了。	具体就是：HTTP协议是用于从 Web 服务器传输 html 到本地浏览器的传送协议

- [HTTP](https://cyc2018.github.io/CS-Notes/#/notes/HTTP)




#### URI 和 URL 概念

URI 统一资源标识符，相当于身份证

URL 统一资源定位符，相当于住址





#### 请求报文、响应报文头都有什么字段？

可以简单回答：
请求报文：
	- 请求行 request line
    - 请求头 request header
    - 请求体 request body

响应报文：
	- 状态行 response line
    - 响应头 response header
    - 响应体 response body



直接引出下面一群知识点
- 请求报文：cookie信息、请求方式get还是post

- 响应报文：响应状态码、Cookie信息

另外，首部字段有以下几种，注意这些字段都是在请求、响应头里的！
- 通用首部字段
- 请求首部字段
- 响应首部字段
- 实体首部字段


#### GET 与 POST 区别

1. get 用于拿数据 post 用于写数据
2. get 会把参数直接带在url后，而post会放在data里。
3. get 提交的报文有最大数据长度限制好像是2k，而 post 没有最大数据长度限制。
4. get 请求会把 header 和 data 一起发送出去；而 post 会先发 header 收到 100 响应状态码之后再发 data
5. get 是幂等的，post 不是幂等的。

这里的**幂等性*：幂等性是指一次和多次请求某一个 URL 应该返回同样的结果，其实就是不改变服务器的状态



#### HTTP 状态码

- 100 continue
- 200 成功
- 3xx 重定向
	- 301 永久重定向
    - 302 临时重定向
- 4xx 是客户端请求错误
	- 400 报文中存在语法错误
    - 403 请求被拒绝
    - 404 资源不存在
- 5xx 是服务器错误
	- 503 服务器处于超负荷或正在停机维护状态，现在无法处理请求




#### 转发和重定向区别？

  转发的话，客户端只发一次请求，收到一次响应，相当于服务器把请求转发给了另一个 URL。

  重定向就是告诉客户端我的 URL 变了，让去另一个地方找，需要客户端进行多次请求。


#### Cookie 和 Session

- 先说问题背景，要解决什么问题？HTTP 是无状态的协议，所以 Cookie Session 主要是为了保存一些客户端的状态信息。

- 点出是什么：首先 Cookie 是存在浏览器里的，而 Session 是存在服务器里的。

  Cookie 是由服务器产生，放在响应里的 set-cookie 字段里，发到客户端，客户端保存后，在下次请求的时候把 cookie 带上就好了。

  Session 是保存在服务器里的，也是由服务器生成，生成后会发送一个 sessionID 字段到 cookie 里，发给客户端，客户端再次请求时，会把这个字段发到服务器，服务器根据 sessionID 识别是哪个客户端了。






#### 禁用 Cookie 还能用 Session 吗？

URL 重写技术，把 sessionID 直接写到 URL 里传上去就可以了。




#### 长连接、流水线

首先解释一下长连接：
  比如我访问一个图很多的网站，如果对每个图建一个连接，那么会耗费大量的资源，这就是短连接
  长连接意思就是我建立一个长时间的连接，在这个连接过程中我可以不断的发请求。
- HTTP 1.1 之前默认短链接，有一个HTTP头部的字段可以设置 Connection：close
- 1.1 之后就默认 Connection：Keep-Alive


  解释一下流水线：一请求、一响应，只有等第一个请求的响应到达之后才能发第二个请求，流水线就可以连续发出请求，


#### 【HTTPS】HTTP 和 HTTPS 的区别 / 讲讲 HTTPS？

[HTTPs1](https://zhuanlan.zhihu.com/p/36981565)
[HTTPs2](http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html)

1. 其实 HTTP 存在这么一些问题：有这么三个：
	- 窃听：可能被第三方窃听
    - 伪装：也就通信双方的身份信息无法确认
    - 篡改：报文也可能被篡改
    
2. 那么 HTTPS 其实就是为了解决这三个问题而存在的，也不算是什么新的协议，他就是运行在SSL协议之上的，而 SSL 协议又运行在TCP之上。

3. 通过SSL协议，采用对称加密和非对称加密的**混合加密**方式，HTTPS有了加密、认证、报文完整性保护 这么三个功能。

分别说说加密、认证、完整性保护是怎么实现的？
- 加密：通过对称加密和非对称加密一起使用，在通信开始，使用非对称加密传输对称加密用的秘钥，之后的通信采用对称加密的方式保证效率。
- 认证：非对称加密的问题是公钥可能被第三防伪造，所以就引入了 CA 这个第三方机构，来保证服务器是真实可靠的。
- 防篡改：在传输㝔时，把报文计算一个 md5 摘要一起传过去，虽然http也这么做但是可以被解密后重新计算摘要。但 https 就不会，我没有私钥是破解不出完整的报文的，也就没办法对摘要进行重新计算。





====== 下面不用看了 ======
**助记**：认证是怎么认证的，HTTPS传输对称加密的密钥时用的是非对称加密，传输过去之后，用的是对称加密。而我在非对称加密时存在一个问题，就是公钥伪造的问题。所以就引入了大家都信任的CA机构，服务器需要先去找CA认证，CA验明身份后用自己的私钥给服务器的信息加个签名，然后服务器拿到这个证书之后发给客户端，客户端本身就内置了CA的公钥，这样就可以验证服务器的身份了。











#### 【对称加密】对称加密/非对称加密，为什么会不安全呢？

1. 对称：效率高，但不安全。
2. 非对称：效率低，但安全。
3. 从不安全的核心来说，非对称加密时，公钥有可能被伪造，所以如果有一个大家都信任的机构，他的**公钥**大家都信任，都知道是正确的，这样就可以保证拿到的信息就是对方所签发的。

#### 【SSL】SSL 连接过程

问题：过程？怎么保证不被篡改？怎么保证就是服务器发出来的？其实就是那三个防窃听、加认证、防篡改如何实现的。
1. 客户端发出请求
2. 证书发给客户端
3. 客户端拿到证书，和 CA 验证，看是否是真正 CA 签发的。
4. 如果是，则用证书中拿下来的服务器的公钥，加密我随机生成的一个对称加密所用的密钥，发给服务器
5. 服务器用私钥解密，拿到对称密钥。
6. 可以开始通信了。

#### 缓存、max-age 字段在请求和响应头里的意思、Expires 字段

- [Expires 和 max-age 的区别](https://www.cnblogs.com/yinhaiming/articles/1490811.html)
- [Expires vs max-age, which one takes priority if both are declared in a HTTP response?
](https://stackoverflow.com/questions/7549177/expires-vs-max-age-which-one-takes-priority-if-both-are-declared-in-a-http-resp)

- Expires：绝对时间
- Cache-control：max-age：相对时间




#### HTTP/2

#### 版本比较

#### HTTP 与 FTP

## 数据库

<!--Note-->
### 资料

- 《MySQL 必知必会》
- [Leetcode](https://leetcode.com/problemset/database/)
- 《高性能 MySQL》
- 《MySQL 技术内幕》
- 《Redis 设计与实现》
- 《Redis 实战》
- 《大规模分布式存储系统》
<!--/Note-->

### SQL

#### 外联结（左右）、内连接（招行面试）

#### 手写分组查询

#### 手写连接查询

#### 连接与子查询

#### drop、delete、truncate

#### 视图

- 视图的作用，以及何时能更新视图。

#### 存储过程

#### 触发器

### 数据库系统原理

#### 事务是什么？

  事务就是一组满足 ACID 特性的操作，要么都执行，要么都不执行。

  比如银行转账，A 给 B 转账，要么 A 的钱扣款，B 收到转账；要么 A 的钱扣款失败，B 没有收到转账；不能 A 的款扣掉之后 B 没收到转账，或者 A 的款没扣，B 收到了转账



#### 事务 ACID

1. Atomicity 原子性，表示事务是密不可分的一组操作。
2. Consistency 一致性，就是数据库在事务执行前后都需要保持一致性的状态。在一致性状态下，所有事务对同一个数据的多次读取结果都是相同的。
3. Isolation 隔离性，一个事务所做的修改在最终提交以前，对其它事务是不可见的。隔离性描述的是事务执行过程中互相影响的情况。事务隔离有不同的级别，包括：读取未提交，读取已提交，可重复度，可串行化读。
4. Durability 持久性： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

#### 并发一致性错误

有三种，脏读、不可重复读、幻读。

1. 脏读：在我这个事务执行的过程中，读了其他事务修改未提交的数据。（A给B转账3000，C读B账户，A回滚，C读到的是脏数据）

2. 不可重复读：在我这个事务内，多次读取同一个数据，在读取过程中其他事务对数据做了修改，造成我这个事务前后读到的数据不一样，就是不可重复读。

3. 幻读：在我这个事务执行的过程中，我多次读取同一段数据，在读取过程中其他事务插入了几行数据，造成我这个事务发现前后读到的数据的行数不一样，好像发生了幻觉一样。

#### 隔离级别

有四种：读已提交、读未提交、可重复度、可串行化。

- 读未提交：什么都不解决。
- 读已提交：可以解决脏读问题。
- 可重复读：可以解决脏读和不可重复读问题。
- 可串行化：可以解决所有问题。



#### 三大范式

  首先三大范式主要是用于数据规范化的！

  如果设计不规范的话，会出现很多问题，举个例子：
  比如一张表：
  {学生号, 课程号} -> {学生学院, 课程成绩}
  也就是说，知道了学生号和课程号之后，才能确定其他信息。
  这样的话会出现这几种错误：
  1. 信息冗余：比如一个学生可能有多门课程，这样学生信息就有很多冗余。
  2. 增加异常：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。
  3. 删除异常：删除一个信息，那么也会丢失其它信息，比如一个学生只选了一门课，现在这门课停开了，我把这个课程删除了，这学生也直接给删没了。
  4. 更改异常：比如我要修改一个课程的名字，那么修改了一个记录中的课程名字，但是另一个记录中相同的课程名字我没改
  
  
**第一范式**：要求数据库的每一列都是不可分割的原子数据项。比如我学历和年级，不能放在一个字段里。

**第二范式**：满足第一范式的前提下，每个非主属性完全函数依赖于键码。比如一张表有两个主键，那么这一行的数据值不能只依赖于其中一个键存在。

**第三范式**：满足前两个范式的前提下，非主属性不传递函数依赖于键码。不能有 A 确定 B，B 确定 C 这样的依赖关系存在。








#### 封锁

封锁的类型以及粒度，两段锁协议，隐式和显示锁定。

#### 乐观锁与悲观锁

#### SQL 与 NoSQL

MySQL不香吗，为什么还要noSQL？https://zhuanlan.zhihu.com/p/136257627

### MySQL

#### 索引、五个实践、失效写法

这只是一个提纲：答案在下面！
- why？
- mysql底层用的什么？
- 和B对比、和hash对比、和红黑对比
- 用B+优缺点
- 最佳实践，不能给所有的都创建
- InnoDB 的两种索引机制，回表操作
- 哪些操作会使得索引失效呢？


========= 下面是答案 =========
1. 首先索引是干什么的？
  其实是一种数据结构，可以加快我们的检索速度
  
2. MySQL 的底层默认是InnoDB引擎，用的是 B+ 树索引
	- B+ 树是一种典型的N叉树，其每个节点有N个子节点就对应着 N个key
    - 除了叶子节点以外，其余所有节点只存索引，不放数据
    - 叶子节点是一个链表，存了所有的数据，B+树的搜索总是可以到达叶子节点的。

3. 其他数据结构为什么不能做索引？
3.1 **和B树做比较**
	其实B树能完成的，B+树也都嫩古玩城，因为宏观上都是增加了结点的容量，降低了树高，然而B+树有两个额外的特性，一是只有叶子节点存数据，二是叶子节点是一个双链表，这两个特性决定了在某些场景下，B+ 树的性能优于 B 树的：
    1. 首先是扫库扫表方面，B+ 只需要遍历叶子节点这个链表，而B树需要扫整颗树。
    2. 范围查找效率高，前者只需遍历其链表的叶子节点，B树的每个节点都有数据，所以范围查找的话需要中序遍历。
    3. 磁盘IO效率上高
    4. 查询稳定性，如果B树查一次就直接命中和查到叶子节点才命中的效率不同。而B+就很稳定，因为只有叶子节点有数据。
    
3.2 **和hash索引做比较**
	- hash索引的随机查找速度很快，但是没有范围查找的能力
    
3.3 **和红黑树比较**
	- 红黑的出度太小，树高从而就高。
    
4. 用了 B+ 树做索引有什么优缺点？
	- 优点无非就是加快检索速度，减少分组排序的过程，把随机IO变成顺序IO
    - 缺点呢就是空间换时间，为一列创建索引需要把这一列复制出来，并且维护索引需要一定的时间。


5. 最佳实践是什么？
	- MAX MIN
    - WHERE
    - ORDER BY、GROUP BY
    - 外键

6. MySQL 的 InnoDB 两种索引，回表操作
	- 聚集：就是主键索引，叶子放了主键和数据
    - 非聚集，就是非主键索引，叶子放了主键，如果不能覆盖查询（比如想要名字列，而名字列本身就是索引）需要回表操作。
	
7. 哪些操作会使索引失效？
	- % 开头的like
    - OR 前后没一起使用索引
    - AND 需要满足最左匹配原则。
    
    
    
    
    
    
    
    
    



#### 如何定位和优化慢 SQL

定位慢SQL：
> https://www.cnblogs.com/xk920/p/11132038.html

1. 使用 SET GLOBAL slow_query_log = ON; 打开慢sql日志记录

2. 使用 explain 查看是否走索引，以及中间有没有临时表的产生。


解决慢 sql：
1. 加索引
2. 修改慢sql，尽量走索引。



#### InnoDB 的聚集索引、非聚集索引、覆盖索引

- MySQL 的 InnoDB 两种索引，回表操作
	- 聚集：就是主键索引，叶子放了主键和数据
    - 非聚集，就是非主键索引，叶子放了主键，如果不能覆盖查询（比如想要名字列，而名字列本身就是索引）需要回表操作。
	
    
    
    
    
    
    
    
    
    



#### InnoDB 的隔离级别默认是什么？MySQL 事务是如何实现的？（MVCC、NKL）

- 默认是第二个级别：**可重复读**

- MVCC 多版本并发控制，实现提交读和可重复读这两种隔离级别。
	- 基于一个统计学的角度，实际场景中，读操作往往多于写操作，所以引入读写锁来避免不必要的加锁操作。读的时候读旧版本不加锁，写的时候写新版本，加锁
	- 而 MVCC 在**读写锁**的基础上又引入了**多版本控制**的思想，写操作更新最新的版本快照，而读操作去读旧版本的快照，没有互斥关系，这一点和 CopyOnWrite 类似。

	- 因为脏读和不可重复读最根本的原因是我这个事务读取了其它事务没有提交的修改，所以在读操作时，MVCC 规定**只能读取已经提交过的快照**，**未提交的快照**和**已提交的快照**是两个版本，互不干涉。



- 幻读问题靠 next-key locks 解决，具体就是加行锁和间隙锁来锁定一段表，可以解决幻读的问题


#### InnoDB 与 MyISAM 区别

1. InnoDB 支持事务，MyISAM 不支持事务。
2. MyISAM 只能对整张表加锁，InnoDB 可以单独对行加锁。
3. InnoDB 还支持外键
4. InnoDB 支持在线热备份。



#### InnoDB 的叶子节点是单向还是双向的？

- 数据页是双向的
- 每个节点里面单条数据是单向的

#### InnoDB 聚簇索引的优点？

#### 关系型和非关系型数据库的区别和特点？

#### 水平切分与垂直切分

#### 主从复制

#### 日志

### Redis

#### 为什么要用缓存？

1. 为什么要用 Redis？
  数据库连接太多的话会把数据库干崩溃，换句话说就是 MySQL 数据库并发性能很差，所以要用 Redis 做缓存，把热点数据缓存到 Redis 里，Redis 并发性能很好，能撑的住 11w/s 级别的读和 8w/s 级别的写。

#### Redis 缓存为什么这么快？

2. 为什么 Redis 速度快？
  是因为是基于纯内存的一个 NoSQL 数据库，相当于直接操作内存，那能不快吗？

#### Redis 并发性能为什么这么好？

3. 为什么 Redis 并发性能好？
3.0 **完全基于内存**
内存操作比磁盘操作要快得多。

3.1. **单线程处理**
  网络请求模块使用一个线程来完成，原理上采用了 IO 多路复用的特性，因此可以处理大量的连接。可以展开讲 IO 复用模型。

3.2. **是基于事件驱动程序**
  一般来说有这个文件事件和时间事件，我可以详细说一下我对这个文件事件的理解。
  首先说下文件事件处理器的结构，主要包含了四个部分：套接字连接、IO 多路复用器、文件事件分派器、事件处理器。
  那么他的详细功能和流程是什么呢？
  1. 首先是套接字：每当一个套接字准备好执行连接应答（accept）、写入（write）、读取（read）、关闭（close）等操作时， 就会产生一个文件事件。 因为一个服务器通常会连接多个套接字， 所以多个文件事件有可能会并发地出现。
  2. IO 多路复用程序：负责监听这些套接字，当他们产生事件时，I/O 多路复用程序总是会将所有产生事件的套接字都入队到一个队列里面， 然后通过这个队列， 以有序（sequentially）、同步（synchronously）、每次一个套接字的方式向文件事件分派器传送套接字： 当上一个套接字产生的事件被处理完毕之后（该套接字为事件所关联的事件处理器执行完毕）， I/O 多路复用程序才会继续向文件事件分派器传送下一个套接字。
  3. 文件事件分派器：会根据先前套接字绑定的事件类型，调用相应的事件处理器，这些处理器可以认为是一个个函数，他们定义了某个事件发生时，服务器应当执行的动作。
  
  
  
  

#### Redis 与 Memchached 的比较

1. redis 支持的数据格式比 memcache 更多
2. redis 支持数据持久化，memcache 不支持
3. redis 有容灾机制，memcached 没有
4. redis 处理网络请求采用单线程模型，而 memcache 采用多线程异步 IO 的方式



#### Redis 的数据类型

1. String key 都是这个类型

2. List：跳表实现

3. Set：集合

4. Map
	- 拉链存储：数组 + 链表实现
	- rehash 扩容的时候是两个数据结构！渐进式 Hash
    
5. ZSet：带权重的集合


#### Redis 的缓存过期和删除机制？

```Redis
EXPIRE com:time 100;
ttl com:time;
```

1. why? 为什么要设置过期时间呢？
    因为内存是有限的，如果内存里所有数据都一直保存的话，过不了多长时间就 OOM 了。
    再一个，有的场景下，比如手机短信验证码可能只在一分钟有效，用户登录状态的 session 只在一天有效。都可以通过设置过期时间来生效。
    Redis 可以通过 exp 命令设置数据的缓存时间。
  
2. How？过期数据的删除策略是什么？
    策略有两种，分别是惰性删除和定期删除。
  - 惰性删除：只会在取出 key 的时候才对数据进行过期检查，这样对 CPU 最友好，但是可能造成太多过期的 key 没有被删除。
  - 定期删除：每隔一段时间抽一批 key 来删除过期的 key，Redis 底层会通过限制删除操作执行的时长和频率来减少删除对 CPU 时间的影响。
  - Redis 两种都用了，资料来自 Redis 重点回顾 _w3cschool



#### Redis 的内存淘汰机制？

3. Redis 内存淘汰机制
    为什么已经有了缓存过期机制，还要有内存淘汰机制呢？
    因为虽然有过期时间，但总要有内存用满的时候，所以就有这个内存淘汰机制，其实和 CPU 的页面置换算法差不多。

volatile：从已设置过期时间的键中，
  -lru：最少使用的数据进行淘汰。
  -lfu：最少使用频率数据进行淘汰
  -ttl：将要过期的数据进行淘汰
  -random：随机淘汰

allkeys：从所有的键中
  -lru：最少使用的数据进行淘汰。
  -lfu：最少使用频率数据进行淘汰
  -random：随机淘汰


#### Redis 的持久化机制 RDB 和 AOF

why?
  为什么要持久化，Redis 是内存数据库，断电即失，所以要有持久化的机制在，否则一旦宕机损失会很大。

how?
主要是 RDB 和 AOF
  1. RDB 主要是全量存储，把 Redis 服务器的所有键值对都保存下来，断电恢复的话直接把整个 RDB 文件读下来就可以恢复之前的状态。有三种触发规则：

    1.1 配置文件里 save 900 1，900s 内，只要有 1 次 key 修改命令，就执行 RDB 
    1.2 执行 flushall 也会执行 RDB 持久化
    1.3 Redis 退出也会出发 RDB


  2. AOF 主要是增量存储命令，断电恢复的话就是把 AOF 里的命令又全部执行了一遍。三个可选配置：

    2.1 always 每次命令都会执行
    2.2 everysecond 每秒一次（最佳实践）
    2.3 no（由操作系统决定什么时候 AOF）

#### Redis 缓存穿透、缓存击穿、缓存雪崩问题？

1. 缓存穿透
    缓存里和数据库里都**没有要查询的数据**，但还是有请求一直在查询这个数据，造成数据库压力过大。

解决方案：
  - 缓存空对象
  - **布隆过滤器**把**不合法请求**过滤掉（k 个 hash 函数，长度为 n 比特的数组，每个 key 映射出 k 个 n 以内的数值，映射到这个数组上，把对应位置涂为 1，这样在下次时用同样的 k 个哈希映射出来的整数去数组里找，如果都为 1 则认为这个 key 在 bloom 里存在）


2. 缓存击穿
    缓存击穿指的是一个热点 key 本身已经抗着大量的并发，在他过期时，瞬间大并发集中对这一个 key 进行访问，在这个 key 失效，持续的大并发就穿破缓存，直接请求到数据库，造成数据库崩溃。

解决方案：
  - 设置永不过期。
  - 加分布式锁，保证对于每个 key 同时只有一个线程去查询数据库，其他线程拿不到分布式锁就不能访问 MySQL。


3. 缓存雪崩
    在某一个时间段内，缓存集中失效了。比如双十一的零点，把商品集中放在了缓存里，设置了过期时间为 一个小时，到了凌晨一点钟的时候，商品缓存集中过期，会有大量的查询打到 MySQL 上，存储层可能也会挂掉。

解决方案：
  - 限流降级：在雪崩时，通过加锁或者队列来控制读数据库和写缓存的线程数量，比如对一个 key 只允许一个线程查询数据和写缓存，其他线程等待。
  - 数据预热：在正式部署之前，先把可能的数据预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中，在即将发生大并发访问前手动触发加载缓存不同的 key，设置不同的过期时间，让缓存失效的时间尽量均匀一些。
  - 集群部署：把热点数据均匀分布在不同的缓存中。











#### Redis 的字典和跳跃表

1. 哈希表
    和 Java 的 HashMap 一样都是采用拉链式的方法来解决哈希冲突。
    不一样的地方 Redis 的字典有两个哈希表，扩容时和 Java 的一次性扩容不一样，他在扩容时为了减轻服务器压力，采用渐进式扩容的办法，渐进的把一个哈希表内的哈希值 rehash 到另一个哈希表，在全部 rehash 结束之后，两个哈希表互换角色。


2. 跳跃表
  what?
    是基于多指针的有序链表实现的，可以看成是多个有序链表，给原始链表建立多层的范围索引，在查找的时候，从最上层最宽泛的索引查找，每次缩小范围，直到在原始链表中找到元素，直到找到对应的节点。查询复杂度是 O(logN)

why? 为什么不用红黑树呢？
- 查找区间元素的效率没有跳表高
- 插入元素无需平衡策略
- 跳表更加灵活，通过改变索引构建策略，有效平衡效率和内存的消耗。




#### Redis 事务

  Redis 的单条命令是保证原子性的，但事务不保证原子性。
  我理解 Redis 事务是提供了
  - multi 开始事务命令
  - exec 执行事务命令
    这样一种把多个命令请求打包的功能，然后再按照顺序执行打包的所有命令，并且中途不会被打断！


=== 下面的看看就行，不用主动说 ===
- 不支持回滚
- 不满足原子性
- 不满足持久性


#### Redis 使用场景！！！

1. 缓存热点数据
2. 计数器（统计点赞数量，请求次数）
3. 查找表，DNS 查找表
4. 也可以做消息队列，List 可以当队列使用。生产者 lpush，消费者 rpop

#### Redis 集群部署方式有哪些？

#### 集群与分布式

## 设计模式

<!--Note-->
### 资料

- 《Head First 设计模式》
<!--/Note-->

### 设计原则

SOLID 原则不需要掌握，知道三个就可以了。

### 对设计模式的理解，三大原则？目的、手段、基础？

目的：在程序设计的时候需要注重程序的可扩展性，可复用性，可维护性，所以要遵循一些原则。

原则：我们常说的
- 单一职责原则
- 面向接口原则
- 开放封闭原则
- 理解：把变化的和不变的给分开，不变的代码要封死了，在不变的代码的基础上机械能扩展可变的代码。

手段：所有设计模式都是为了程序的可扩展性、可复用性、可维护性。可以把设计模式说成是一种原则，也可以说是一种工具，这个原则来约束我们写出可复用性好、可维护性强、可扩展性好的代码。

基础：而这一切的基础就是，继承和多态。




### 单例模式，知道 volatile 在这里的作用么？

手写单例模式，特别是双重检验锁以及静态内部类。

1. volatile 的作用就举个例子就完事儿了



### 工厂模式

手写工厂模式。


### MVC

理解 MVC，结合 SpringMVC 回答。

### 代理模式

手写代理模式
结合 Spring 中的 AOP 回答。

### 装饰者模式

结合 jkd 源码说，举例

### 适配器模式

结合 jkd 源码说，举例说明

### 迭代器模式

结合 jkd 源码说，举例说明

### JDK 中常用的设计模式，就是这所有牵涉到 JDK 设计模式问题的总和

例如装饰者模式、适配器模式、迭代器模式等（tong'shang）

## 框架基础问题

- [69 道 Spring 面试题和答案](http://ifeve.com/spring-interview-questions-and-answers/)
- [Spring 面试题](https://github.com/Homiss/Java-interview-questions/blob/master/%E6%A1%86%E6%9E%B6/Spring%20%E9%9D%A2%E8%AF%95%E9%A2%98.md)
- [Spring 面试问答 Top 25](http://www.importnew.com/15851.html)
- [Spring 总结以及在面试中的一些问题.](https://www.cnblogs.com/wang-meng/p/5701982.html)


### Spring

#### Spring Bean 的线程安全问题

#### IOC 和 AOP

#### Spring 循环依赖问题

让阿里面试官都赞不绝口的Spring解读，没人比我更懂循环依赖！ - Java架构莫西的文章 - 知乎
https://zhuanlan.zhihu.com/p/186212601

怎么回答面试官：你对Spring的理解？ - bravo1988的回答 - 知乎
https://www.zhihu.com/question/48427693/answer/723146648

太可惜了，Spring中的循环依赖问题，只有10%的人才算“真的懂” - Java程序猿阿谷的文章 - 知乎
https://zhuanlan.zhihu.com/p/157611040


### SpringMVC

#### SpringMVC 的好处

why? how?回答
why? 解决了什么问题？
SpringMVC 的最大的好处就是屏蔽了 Servlet 底层的一些细节，把 Servlet 容器封装起来我们直接用就行了。

比如：
- 在使用 Servlet 的时候，要获得表单的参数就得写 getParameter，如果表单大的话就得写很多这个 getParameter，而 SpringMVC 可以直接把表单封装到 pojo 里，很方便。
- 在 xml 里配置 servlet 也是一个麻烦事儿，而 SpringMVC 只提供了几个注解就可以完成配置。





#### SpringMVC 架构？MVC 分别是什么？

M：model 数据模型，用于提供要展示的数据，一般包含数据和数据的行为，但是现在一般都分开来看了，也就是数据 dao 层和 行为 service 层，总的来说 model 就是提供了数据查询和数据状态更新的功能。

V：View 视图，负责进行数据模型的展示，一般就是前端页面，用户想看到的东西。

C：Controller 接收用户的请求，相当于一个中介，委托给 model 进行处理，处理完毕之后把返回的 model 返回给 View，由视图进行展示。



#### SpringMVC 处理请求的过程

### SpringBoot

#### 自动配置的原理

### MyBatis

#### MyBatis 的好处在哪里？为什么要用 MyBatis？

why? how? 回答
封装了繁琐的 JDBC 底层的那些 API，statement 那些东西写着非常容易出错，并且可读性差，不好复用。

而 ORM 框架的优势就是，消除了大量的 JDBC 的 API，sql 从 java 代码中解放了出来，写到 xml 配置里，可复用，可读性好！

#### ORM 框架有什么作用？

通上

#### # 和 $ 有什么不同？

<$> 是字符串替换，有sql注入的危险，sql注入就是一些用户的输入被当成了sql语句的一部分进行执行。

<#> 是预编译命令，可以避免sql注入的风险。

#### 为什么写一个 Mapper 就可以映射了，是如何工作的？

#### MyBatis 缓存有几级？
