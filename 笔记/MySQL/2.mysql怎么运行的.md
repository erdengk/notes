# 1章

### 连接管理

mysql服务器回味每一个连接进来的客户端分配一个线程

### 解析与优化

从mysql5.7.20开始，不推荐使用查询缓存，在mysql8.0中直接删除

### 存储引擎

```
show engines；
```

## 第2章

## 第3章

==编码==

将字符映射成二进制数据的过程叫做编码

==解码==

将二进制数据映射到字符的过程叫做解码

### 字符集

ASCII 字符集，128字符

GB2312 字符集

GBK字符集

UTF-8 几乎是所有国家的文字

### mysql 中的utf8 和utf8mb4

Utf8mb3 只使用1-3字节表示字符

Utf8mb4  用1-4字节表示字符

8.0中默认用Utf8mb4



## 第4章 InnoDB记录存储结构

InnoDB将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位。

页的大小一般为16Kb

## InnoDB行格式

COMPACT、redundant、daynamic、compressed四种格式

### COMPACT

![](https://relph1119.github.io/mysql-learning-notes/images/04-01.png)

一条完整的记录其实可以被分为记录的额外信息和记录的真实数据两大部分

```
InnoDB在读记录的变长字段长度列表时先查看表结构，如果某个变长字段允许存储的最大字节数不大于255时，可以认为只使用1个字节来表示真正字符串占用的字节数。
```

如果该可变字段允许存储的最大字节数（`M×W`）超过255字节并且真实存储的字节数（`L`）超过127字节，则使用2个字节，否则使用1个字节

##### NULL值列表

我们知道表中的某些列可能存储`NULL`值，如果把这些`NULL`值都放到`记录的真实数据`中存储会很占地方，所以`Compact`行格式把这些值为`NULL`的列统一管理起来，存储到`NULL`值列表中

### InnoDB表对主键的生成策略

优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个`Unique`键作为主键，如果表中连`Unique`键都没有定义的话，则`InnoDB`会为表默认添加一个名为`row_id`的隐藏列作为主键

# 第5章 盛放记录的大盒子-InnoDB数据页结构

## 记录在页中的存储

我们自己存储的记录会按照我们指定的`行格式`存储到`User Records`部分。但是在一开始生成页的时候，其实并没有`User Records`这个部分，每当我们插入一条记录，都会从`Free Space`部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到`User Records`部分，当`Free Space`部分的空间全部被`User Records`部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了，这个过程的图示如下：

![img](https://relph1119.github.io/mysql-learning-notes/images/05-02.png)

### 行格式示意图

行格式示意图就是这样的：

![img](https://relph1119.github.io/mysql-learning-notes/images/05-03.png)



| 名称           | 大小（单位：bit） | 描述                                                         |
| -------------- | ----------------- | ------------------------------------------------------------ |
| `预留位1`      | `1`               | 没有使用                                                     |
| `预留位2`      | `1`               | 没有使用                                                     |
| `delete_mask`  | `1`               | 标记该记录是否被删除                                         |
| `min_rec_mask` | `1`               | B+树的每层非叶子节点中的最小记录都会添加该标记               |
| `n_owned`      | `4`               | 表示当前记录拥有的记录数                                     |
| `heap_no`      | `13`              | 表示当前记录在记录堆的位置信息                               |
| `record_type`  | `3`               | 表示当前记录的类型，`0`表示普通记录，`1`表示B+树非叶节点记录，`2`表示最小记录，`3`表示最大记录 |
| `next_record`  | `16`              | 表示下一条记录的相对位置                                     |



### 被删除的记录

删除的记录还在`页`中么？是的，摆在台面上的和背地里做的可能大相径庭，你以为它删除了，可它还在真实的磁盘上[摊手]。这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后把其他的记录在磁盘上重新排列需要性能消耗，所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的`垃圾链表`，在这个链表中的记录占用的空间称之为所谓的`可重用空间`，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。



 删掉第2条记录后的示意图就是：

![img](https://relph1119.github.io/mysql-learning-notes/images/05-09.png)

==不论我们怎么对页中的记录做增删改操作，InnoDB始终会维护一条记录的单链表，链表中的各个节点是按照主键值由小到大的顺序连接起来的。==

## Page Directory（页目录）

==页目录==的制作过程是这样的：

1. 将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。
2. 每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的`n_owned`属性表示该记录拥有多少条记录，也就是该组内共有几条记录。
3. 将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近`页`的尾部的地方，这个地方就是所谓的`Page Directory`，也就是`页目录`（此时应该返回头看看页面各个部分的图）。页面目录中的这些地址偏移量被称为`槽`（英文名：`Slot`），所以这个页面目录就是由`槽`组成的。

单纯从逻辑上看一下这些记录和页目录的关系：

![img](https://relph1119.github.io/mysql-learning-notes/images/05-13.png)

设计`InnoDB`的大佬们对每个分组中的记录条数是有规定的：对于最小记录所在的分组只能有 ***1\*** 条记录，最大记录所在的分组拥有的记录条数只能在 ***1~8\*** 条之间，剩下的分组中记录的条数范围只能在是 ***4~8\*** 条之间。

==在一个数据页中查找指定主键值的记录的过程分为两步：==

1. 通过二分法确定该记录所在的槽，并找到该槽中主键值最小的那条记录。
2. 通过记录的`next_record`属性遍历该槽所在的组中的各个记录。

![img](https://relph1119.github.io/mysql-learning-notes/images/05-14.png)

想找主键值为`6`的记录，过程是这样的：

1. 计算中间槽的位置：`(0+4)/2=2`，所以查看`槽2`对应记录的主键值为`8`，又因为`8 > 6`，所以设置`high=2`，`low`保持不变。
2. 重新计算中间槽的位置：`(0+2)/2=1`，所以查看`槽1`对应的主键值为`4`，又因为`4 < 6`，所以设置`low=1`，`high`保持不变。
3. 因为`high - low`的值为1，所以确定主键值为`5`的记录在`槽2`对应的组中。此刻我们需要找到`槽2`中主键值最小的那条记录，然后沿着单向链表遍历`槽2`中的记录。但是我们前面又说过，每个槽对应的记录都是该组中主键值最大的记录，这里`槽2`对应的记录是主键值为`8`的记录，怎么定位一个组中最小的记录呢？别忘了各个槽都是挨着的，我们可以很轻易的拿到`槽1`对应的记录（主键值为`4`），该条记录的下一条记录就是`槽2`中主键值最小的记录，该记录的主键值为`5`。所以我们可以从这条主键值为`5`的记录出发，遍历`槽2`中的各条记录，直到找到主键值为`6`的那条记录即可。由于一个组中包含的记录条数只能是1~8条，所以遍历一个组中的记录的代价是很小的。