![image-20220918174620934](https://raw.githubusercontent.com/erdengk/picGo/main/img/202209181918039.png)



# 类加载与字节码技术

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210210200506952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70)





## 1、类文件结构

```bash
u4 			   magic
u2             minor_version;    
u2             major_version;    
u2             constant_pool_count;    
cp_info        constant_pool[constant_pool_count-1];    
u2             access_flags;    
u2             this_class;    
u2             super_class;   
u2             interfaces_count;    
u2             interfaces[interfaces_count];   
u2             fields_count;    
field_info     fields[fields_count];   
u2             methods_count;    
method_info    methods[methods_count];    
u2             attributes_count;    
attribute_info attributes[attributes_count];
```

1）魔数
u4 magic
对应字节码文件的 0~3 个字节
0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09
ca fe ba be ：意思是 .class 文件，不同的东西有不同的魔数，比如 jpg、png 图片等！

2）版本
u2 minor_version;
u2 major_version;
0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09
00 00 00 34：34H（16进制） = 52（10进制），代表JDK8

3）常量池

## 2、字节码指令

### 1) javap 工具

Java 中提供了 javap 工具来反编译 class 文件

```java
javap -v D:Demo.class
```

### 2) 图解方法执行流程

```java
public class Demo3_1 {    
	public static void main(String[] args) {        
		int a = 10;        
		int b = Short.MAX_VALUE + 1;        
		int c = a + b;        
		System.out.println(c);   
    } 
}
```

**常量池载入运行时常量池**
常量池也属于方法区，只不过这里单独提出来了

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210210230332114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70)



**方法字节码载入方法区**
（stack=2，locals=4） 对应操作数栈有 2 个空间（每个空间 4 个字节），局部变量表中有 4 个槽位。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210210230419340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70)



**执行引擎开始执行字节码**
**bipush 10**

- 将一个 byte 压入操作数栈（其长度会补齐 4 个字节），类似的指令还有
- sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节）
- ldc 将一个 int 压入操作数栈
- ldc2_w 将一个 long 压入操作数栈（分两次压入，因为 long 是 8 个字节）
- 这里小的数字都是和字节码指令存在一起，超过 short 范围的数字存入了常量池

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210210230611776.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70)

**istore 1**

将操作数栈栈顶元素弹出，放入局部变量表的 slot 1 中
对应代码中的 a = 10

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210210230717611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70)

**ldc #3**
读取运行时常量池中 #3 ，即 32768 (超过 short 最大值范围的数会被放到运行时常量池中)，将其加载到操作数栈中
注意 Short.MAX_VALUE 是 32767，所以 32768 = Short.MAX_VALUE + 1 实际是在编译期间计算好的。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210210230918171.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70)

**istore 2**
将操作数栈中的元素弹出，放到局部变量表的 2 号位置

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210210231005919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70)

**iload1 iload2**

将局部变量表中 1 号位置和 2 号位置的元素放入操作数栈中。==因为只能在操作数栈中执行运算操作==

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210210231211695.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70)

**iadd**
将操作数栈中的两个元素弹出栈并相加，==结果在压入操作数栈中。==

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210210231236404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70)

**istore 3**
将操作数栈中的元素弹出，放入局部变量表的3号位置。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210210231319967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70)

**getstatic #4**
在运行时常量池中找到 #4 ，发现是一个对象，在堆[内存](https://so.csdn.net/so/search?q=内存&spm=1001.2101.3001.7020)中找到该对象，并将其引用放入操作数栈中

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210210231759663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70)

**iload 3**
将局部变量表中 3 号位置的元素压入操作数栈中。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210210232008706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70)

**invokevirtual #5**
找到常量池 #5 项，定位到方法区 java/io/PrintStream.println:(I)V 方法
生成新的栈帧（分配 locals、stack等）
传递参数，执行新栈帧中的字节码

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210210232148931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70)

执行完毕，弹出栈帧
清除 main 操作数栈内容

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210210232228908.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70)

**return**
完成 main 方法调用，弹出 main 栈帧，程序结束

### 3) 通过字节码指令分析问题

#### a++ ++a

```java
/**
* 从字节码角度分析 a++ 相关题目
*/
public class Demo3_2 {
    public static void main(String[] args) {
        int a = 10;
        int b = a++ + ++a + a--;
        System.out.println(a);
        System.out.println(b);
    }
}
```

a=? b=?

部分字节码：

```java
 0: bipush 10
 2: istore_1
 3: iload_1
 4: iinc 1, 1
 7: iinc 1, 1
10: iload_1
11: iadd
12: iload_1
13: iinc 1, -1
16: iadd
17: istore_2
```

分析：

注意**iinc指令(自增指令)**是直接在局部变量slot上进行运算

**iload(读取变量的指令) **

a++ 和 ++a 的区别是先执行**iload(读****取)**还是先执行iinc

- a++ 是先 iload 再 iinc
- ++a 是先 iinc 再 iload

istore_1

将a装载到slot上

![image-20220927174221391](https://raw.githubusercontent.com/erdengk/picGo/main/img/202209271742563.png)

iload_1

a++，先load，再自增

将a，读到操作数栈中

![image-20220927174323634](https://raw.githubusercontent.com/erdengk/picGo/main/img/202209271743699.png)

iinc 1,1  (自增， （value1，value2） value1是对哪个数操作，value2是给value1加多少)

![image-20220927174519965](https://raw.githubusercontent.com/erdengk/picGo/main/img/202209271745029.png)

++a, 先 iinc ，后load，

![image-20220927174606418](https://raw.githubusercontent.com/erdengk/picGo/main/img/202209271746450.png)

ioad_1 

![image-20220927174630735](https://raw.githubusercontent.com/erdengk/picGo/main/img/202209271746779.png)

iadd , 两个数相加

![image-20220927174715454](https://raw.githubusercontent.com/erdengk/picGo/main/img/202209271747488.png)

iload_1 ,读取 a

![image-20220927174758130](https://raw.githubusercontent.com/erdengk/picGo/main/img/202209271747174.png)

iinc  1，-1

![image-20220927174838171](https://raw.githubusercontent.com/erdengk/picGo/main/img/202209271748218.png)

iadd

![image-20220927174858609](https://raw.githubusercontent.com/erdengk/picGo/main/img/202209271748639.png)

istore_2 ,把操作数栈里的值给slot 2位置（也就是b）

![image-20220927174951865](https://raw.githubusercontent.com/erdengk/picGo/main/img/202209271749900.png)

#### x=x++

```java
public class Code_11_ByteCodeTest {
    public static void main(String[] args) {

        int i = 0;
        int x = 0;
        while (i < 10) {
            x = x++;
            i++;
        }
        System.out.println(x); // 0
    }
}
```

```
 iload_2		//将局部变量2号槽位的数放入操作数栈中，放入的值是0
 iinc          2, 1	//将局部变量2号槽位的数加1，自增后，槽位中的值为1
 istore_2   //将操作数栈中的数放入到局部变量表的2号槽位，2号槽位的值又变为了0
```

x++,先load，后iinc

load后

slot 上， x = 0， 操作数栈上  0

iinc 后， x = 1， 操作数上 0 

然后是 = 赋值操作 （将操作数栈上的数取出来，覆盖到本地变量中）

= 操作后， x = 0 （操作数栈上覆盖了）， 操作数栈 0



#### a=a++，a = ++a

```java
    public static void main(String[] args) {
        int a = 10;
        int b = 20;
        int c = 30;
        a++;
        b = b++;
        c = ++c;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c); 
    }
```

部分字节码：

```
 stack=2, locals=4, args_size=1
         0: bipush        10
         2: istore_1
         3: bipush        20
         5: istore_2
         6: bipush        30
         8: istore_3
         9: iinc          1, 1
        12: iload_2
        13: iinc          2, 1
        16: istore_2
        17: iinc          3, 1
        20: iload_3
        21: istore_3

```

istore_x  将操作数栈栈顶元素弹出，放入局部变量表的 slot x中

iload_x 将 局部变量中x位置的元素  放到操作数栈中

iinc 1,1  (iinc， （value1，value2） value1是对哪个位置的数操作，value2是给value1加多少)

对于a

```java
       9: iinc          1, 1 // 将局部变量1号位+1，自增后，1号位置 11
```



对于b

```java
iload_2  //将局部变量2号位置放入操作数栈中，此时操作数栈 20
iinc          2, 1 // 将局部变量2号位+1，自增后，2号位置 21，操作数中 20
istore_2   //将操作数栈栈顶元素弹出，放入局部变量表的2号位置中 此时，2号位置20，操作数中20 
```

对于c

```java
iinc          3, 1 // 将局部变量3号位+1，自增后，3号位置 31，操作数中 空 
iload_3    // 将3号位置放入操作数栈，操作数中 31
istore_3  // 将操作数栈栈顶元素弹出，放入局部变量表的3号位置中，将31赋值给31，此时c=31
```

输出

a=11

b=20

c=31

![image-20220927181203099](https://raw.githubusercontent.com/erdengk/picGo/main/img/202209271812184.png)

### 构造方法

#### cinit()V

```java
public class Demo3 {
	static int i = 10;

	static {
		i = 20;
	}

	static {
		i = 30;
	}

	public static void main(String[] args) {
		System.out.println(i); //结果为30
	}
}
```

编译器会按**从上至下**的顺序，收集所有 static 静态代码块和静态成员赋值的代码，**合并**为一个特殊的方法 cinit()V ：

#### init()V

```java
public class Demo4 {
	private String a = "s1";

	{
		b = 20;
	}

	private int b = 10;

	{
		a = "s2";
	}

	public Demo4(String a, int b) {
		this.a = a;
		this.b = b;
	}

	public static void main(String[] args) {
		Demo4 d = new Demo4("s3", 30);
		System.out.println(d.a);
		System.out.println(d.b);
	}
}
```

- 编译器会按**从上至下**的顺序，收集所有 {} 代码块和成员变量赋值的代码，**形成新的构造方法**，但**原始构造方法**内的代码**总是在后**
- 如果有多个构造函数，则会一一对应生成多个
- 简单说：执行顺序：静态代码块 > 代码块 > 构造方法

### 多态的原理

因为普通成员方法需要在运行时才能确定具体的内容，所以虚拟机需要调用 **invokevirtual** 指令

在执行invokevirtual指令时，经历了以下几个步骤

- 先通过栈帧中对象的引用找到对象
- **分析对象头**，找到对象实际的Class
- Class结构中有**vtable**，它在类加载的链接阶段就已经根据方法的重写规则生成好了
- 查询vtable找到方法的具体地址
- 执行方法的字节码
