```
//请求投票的rpc
term  //当前任期号
candidateld  //自己的id
lastLogIndex // 自己最后一个日志号
lastLogTerm  // 自己最后一个日志的任期
```

请求投票的rpc中会包含最后一个日志的信息（安全性子问题）





日志中包含的信息

状态机指令

leader的任期号

日志索引

（任期号和日志索引唯一确定一条日志）





### 日志复制

分布式中网络不稳定，需要日志复制来保证状态机的中间态相同



#### follower缓慢

如果有follower因为某些原因没有给leader响应，那么leader会不断地重发追加条目请求(AppendEntries RPC)，哪怕leader已经回复 了客户端。

#### follower崩溃恢复

如果有follower崩溃后恢复，这时Raft追加条目的一致性检查生效，保证follower能按顺序恢复崩溃后的缺失的日志。

Raft的一致性检查: leader在 每一 个发往follower的追加条目RPC中，==会放入前一个日志条目的索引位置和任期号==，如果follower在它 的日志中找不到前一个日志，那么它就会拒绝此日志，leader收 到follower的拒绝后，会发送前一个日志条且，从而逐渐向前定位到follower第一个缺失的日志。



#### leader崩溃

③如果leader崩溃，那么崩溃的leader可能已经复制了旦志到部分follower 但还没有提交而被选出的新leader又可能不具备这些日志，这样就有部分follower中的日志和新leader的日志不相同。 

Raft在这种情况下，leader通过强制follower复制它的日志来解决不一致的问题，这意味着follower中跟leader冲突的日志条且会被新 leader的旦志条目覆盖(因为没有提交，所以不违背外部一致性)



●通过这种机制，leader在 当权之后就不需要任何特殊的操作来使日志恢复到一致状态。
●Leader只需要进行正常的操作，然后日志就能在回复AppendEntries-致 性检查失败的时候自动趋于一致。
●Leader从来不会覆盖或者删除自己的日志条目。(Append-Only)
●这样的日志复制机制，就可以保证一 致性特性:
只要过半的服务器能正常运行，Raft就能够接受、复制并应用新的日志条且;

在正常情况下，新的且志条且可以在一个RPC来回中被复制给集群中的过半机器:

单个运行慢的follower不会影响整体的性能。





### 安全性

领导者选举和日志复制两个子问题实际上已经涵盖了共识算法的全程，但这两点还不能完全保证每一个状态机会按照==相同的顺序==执行相同的命令。

所以Raft通过几个补充规则完善整个算法，使算法可以在各类宕机问题下都不出错。

这些规则包括(不讨论安全性条件的证明过程):

1. Leader宕机处理:选举限制
2. Leader宕机处理:新leader是 否提交之前任期内的日志条目
3. Follower和Candidate宕机处理
4. 时间与可用性限制



#### Leader宕机处理:选举限制

现象：

一个follower落后了leader若干条日志（但没有漏一整个周期），那么按照leader选举的规则，它依旧有可能当选leader，它在当选leader后就永远无法补上之前缺失的那部分日志，从而造成状态机之间的不一致

解决思路：

保证被选出来的leader一定包含了之前各任期中所有被提交的日志条目

解决方案：

（比较投票rpc中的日志信息，如果自己的日志号大于投票的日志号，就拒绝，以此来避免出现新选的leader中没有之前提交的日志）

RequestVote RPC执行了这样的限制: RPC中包含了candidate的日志信息，如果投票者自己的日志比candidate的还新，它会拒绝掉该投票请求。

Raft通过比较两份日志中最后一条日志条目的索引值和任期号来定义谁的日志比较新。

如果两份日志最后条目的任期号不同，那么任期号大的日志更“新”。

如果两份日志最后条目的任期号相同，那么日志较长的那个更“新”。

#### Leader宕机处理:新leader是否提交之前任期内的日志条目



leader提交后，返回给客户端（然后宕机了，没有给follower发送提交信息），这种情况怎么处理？

>leader提交和follower提交间，必然会间隔一段时间
>
>如果leader提交之后直接返回客户端
>
>在通知follower提交前，也就是一个心跳的时间内，如果leader宕机
>
>就会出现部分提交的问题

raft 是一种底层的共识算法，本身只是应用实现高可用的一种方式，而与客户端交互本来应该是属于应用端的事情，理论上不是raft该担心的，所以论文中也没有讨论这一点。

==原生的raft并没有做处理，是后面自己实现时，设置了集群提交==



> 应用会设置一个集群提交的概念，只有集群中超过半数的节点都完成提交，才认为集群提交完成



raft不是通过计算副本数目的方式来提交之前任期内的日志

只有自己任期内的日志才能通过计算副本数目来提交





#### Follower和Candidate宕机处理

raft通过无限的重试来处理这种失败，如果奔溃的机器重启了，这些rpc就能成功



#### 时间与可用性限制