## 11.3 滴滴准实习员工模拟面--简单复盘版

滴滴准实习员工模拟面，1h 



### 自我介绍

巴拉巴拉

```
继续练，还没特别熟
```



### 项目介绍

### edis

> redis过期策略



> 比如说我们数据库当中有 2000 万的数据，然后我 Redis 它只存 20 万的数据，然后让你来设计，你要怎么设计呢？

LRU策略



>但是你看我们传统的 LRU 的话，那它造成的这个缓存污染怎么办？比如说有一个热点数据，我刚进去，结果刚进去待了很久，然后但是他已经很久没有使用了，但是他就是比如说我们一开始就是我们热点不是最近访问的。然后然后我们这个 Redis 当中有一个比如说有有一个预读机制，就是比如说 A 和 B 数据都进去了，然后他们的访他们只可能就是最近访问了一两次，但是这样他就会导致以前的那些热点数据给清除了。你能就是你觉得这个要怎么办？就是让你来优化一下 LRU 算法，你要怎么优化一下呢？

我们需要一个晋升的阈值，可以参考Linux中优化LRU的算法

就是设计了一个 active 链表，还有一个 inactive 链表。

访问次数在阈值内的会在inactive链表中，超过次数的会晋升到active链表里

Linux 操作系统：在内存页被访问**第二次**的时候，才将页从 inactive list 升级到 active list 里。(自己回答的时候可以说设定一个晋级门槛和inactive list和active list)

**只要我们提高进入到活跃 LRU 链表（或者 young 区域）的门槛，就能有效地保证活跃 LRU 链表（或者 young 区域）里的热点数据不会被轻易替换掉**。


### MySQL

mysql 索引

> innodb中，b+树是怎么实现的？
>
> 就是比如说它是它的叶子节点当中是怎么样连接的，然后里面的数据是怎么连接的？

https://bbs.huaweicloud.com/blogs/317532



> B 加树当中一定要有聚簇索引吗？



>你知道就是 B 加树当中一般是多少层吗？

InnoDB中页大小一般16KB，一般表的**主键类型为INT**(占用4个字节)或BIGINT(8字节），**指针类型一般也是4-8字节**，也就是一个页中大概存储16KB/(8B+8B)=1K个键值（估算K取10三次方），则一个深度为3的B+Tree索引可以维护10亿条记录（9次方，假定一个数据页也是10三次方行记录数据）实际情况中每个节点可能不能被充满，所以高度一般2-4层，而根节点为常驻节点故只需要1-3次。



>然后那索引的优点和缺点你说说。



>你有了解过那个 MVCC 机制吗？
>
>那它底层是通过什么来实现的？





> 它隐藏字段是哪些？你知道吗？



> 你知道读视图主要是包含了哪些重要内容吗？



>它里面就是包含了四个字段，就是包含了四个比较重要的内容，你知道是哪四个吗？



>比如说我读了一条数据，那我们是怎么通过就是我是怎么通过 MVCC 机制来判断我能不能读到这条数据的呢？他的判断规则是什么？



>事物的特性是哪些特性吗？
>
>隔离性它是有哪几个等级呢？



>可重复读不能解决幻读的情况。

可重复读解决幻读是快照读利用了MVCC机制的版本号, 而当前读为强制获取当前数据  故不能解决

快照读：又叫一致性读，读取的是快照数据。不加锁的简单的 SELECT 都属于快照读，即不加锁的非阻塞读；快照读的实现时基于MVCC的。**快照读基于多版本则可能读到历史数据并不是最新的**。快照读的前提时隔离级别不是串行级别，串行级别快照读退化当前读。

当前读：**强制读取记录的最新版本，且上锁。对数据的增删改都会先进行当前读**



### 网络

> 三次握手



>那三次握手，他那个 accept 过程发生在钉哪次握手呢？就是发生在什么时候？就是 Linux 当中不是有一个 accept 就是获取到那个 socket 你知道它是发生在什么时候吗？

三次握手过程

- 客户端的协议栈向服务器端发送了 SYN 包，并告诉服务器端当前发送序列号 client_isn，客户端进入 SYN_SENT 状态；
- 服务器端的协议栈收到这个包之后，和客户端进行 ACK 应答，应答的值为 client_isn+1，表示对 SYN 包 client_isn 的确认，同时服务器也发送一个 SYN 包，告诉客户端当前我的发送序列号为 server_isn，服务器端进入 SYN_RCVD 状态；
- 客户端协议栈收到 ACK 之后，使得应用程序从 `connect` 调用返回，表示客户端到服务器端的单向连接建立成功，客户端的状态为 ESTABLISHED，同时客户端协议栈也会对服务器端的 SYN 包进行应答，应答数据为 server_isn+1；
- ACK 应答包到达服务器端后，服务器端的 TCP 连接进入 ESTABLISHED 状态，同时服务器端协议栈使得 `accept` 阻塞调用返回，这个时候服务器端到客户端的单向连接也建立成功。至此，客户端与服务端两个方向的连接都建立成功。

从上面的描述过程，我们可以得知**客户端 connect 成功返回是在第二次握手，服务端 accept 成功返回是在三次握手成功之后。**



>拥塞控制，我看你这边写了，就是那你知道拥塞控制那几个算法吗？



>快速恢复，你能给我具体说说它是怎么用的吗？



> 四次挥手的过程



>那你知道这个他四次挥手，他有没有可能变成三次挥手呢？



> TCP 和 UDP 它们的区别吧。



>那咱们平时打视频电话的话，它是通过用什么来连接的？



### 并发

> cas原理



> volitale



> 线程和进程





> 操作系统当中进程的通信方式有几种吗？你能说有哪些吗？



### Jvm 

内存结构

> 那咱们平常分配内存都是在哪里分配的？大多数情况。



> 逃逸分析

Java 世界中“几乎”所有的对象都在堆中分配，但是，随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。**从 JDK 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存**。

> 垃圾回收算法



### 算法

手写堆排

前序和后序为什么不能重建二叉树，举例

手写快排





